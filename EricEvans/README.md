<!-- TOC -->

- [第1部](#第1部)
    - [知識を噛み砕く](#知識を噛み砕く)
        - [知識豊富なモデル](#知識豊富なモデル)
        - [深いモデル](#深いモデル)
        - [ユビキタス言語](#ユビキタス言語)
        - [ドキュメントと図](#ドキュメントと図)
        - [説明のためのモデル](#説明のためのモデル)
    - [モデルと実装を結びつける](#モデルと実装を結びつける)
        - [モデル駆動設計](#モデル駆動設計)
        - [モデリングパラダイムとツールによるサポート](#モデリングパラダイムとツールによるサポート)
        - [骨格を見せる](#骨格を見せる)
        - [実践的モデラ](#実践的モデラ)
- [第2部](#第2部)
    - [ドメインを隔離する](#ドメインを隔離する)
        - [レイヤ化アーキテクチャ](#レイヤ化アーキテクチャ)
            - [レイヤを関係づける](#レイヤを関係づける)
            - [アーキテクチャフレームワーク](#アーキテクチャフレームワーク)
        - [ドメイン層はモデルが息づく場所](#ドメイン層はモデルが息づく場所)
    - [ソフトウェアで表現されたモデル](#ソフトウェアで表現されたモデル)
        - [関連](#関連)
        - [エンティティ(参照オブジェクト)](#エンティティ参照オブジェクト)
        - [値オブジェクト](#値オブジェクト)
        - [サービス](#サービス)
        - [モジュール](#モジュール)
        - [モデリングパラダイム](#モデリングパラダイム)
    - [ドメインオブジェクトのライフサイクル](#ドメインオブジェクトのライフサイクル)
        - [集約](#集約)
        - [ファクトリ](#ファクトリ)
            - [ファクトリとその場所を選択する](#ファクトリとその場所を選択する)
            - [コンストラクタがあれば良い場合](#コンストラクタがあれば良い場合)
            - [インターフェースを実装する](#インターフェースを実装する)
            - [不変条件のロジックはどこに置くべきか？](#不変条件のロジックはどこに置くべきか)
            - [エンティティファクトリと対値オブジェクトファクトリ](#エンティティファクトリと対値オブジェクトファクトリ)
            - [格納したオブジェクトを再構成する](#格納したオブジェクトを再構成する)
        - [リポジトリ](#リポジトリ)
            - [リポジトリに対して問い合わせる](#リポジトリに対して問い合わせる)
            - [クライアントのコードはリポジトリの実装を無視するが、開発者はそうではない](#クライアントのコードはリポジトリの実装を無視するが開発者はそうではない)
            - [リポジトリを実装する](#リポジトリを実装する)
            - [フレームワークの範囲内で作業する](#フレームワークの範囲内で作業する)
            - [ファクトリとの関係](#ファクトリとの関係)
            - [関係データベースに合わせてオブジェクトを設計する](#関係データベースに合わせてオブジェクトを設計する)
    - [第7章](#第7章)
        - [貨物輸送システムの導入](#貨物輸送システムの導入)
        - [ドメインを隔離する：アプリケーションの導入](#ドメインを隔離するアプリケーションの導入)
        - [エンティティと値オブジェクトを区別する](#エンティティと値オブジェクトを区別する)
        - [ドメインの関連を設計する](#ドメインの関連を設計する)
        - [集約の境界](#集約の境界)
        - [リポジトリを選択する](#リポジトリを選択する)
        - [シナリオをウォークスルーする](#シナリオをウォークスルーする)
            - [荷出し地の変更](#荷出し地の変更)
            - [リピータへの対応](#リピータへの対応)
        - [オブジェクトの生成](#オブジェクトの生成)
            - [貨物用のファクトリとコンストラクタ](#貨物用のファクトリとコンストラクタ)
            - [荷役イベントを追加する](#荷役イベントを追加する)
        - [リファクタリングのために立ち止まる](#リファクタリングのために立ち止まる)
        - [輸送モデルにおけるモジュール](#輸送モデルにおけるモジュール)
        - [新機能を導入する：配分チェック](#新機能を導入する配分チェック)
            - [2 つのシステムを接続する](#2-つのシステムを接続する)
            - [モデルを強化する](#モデルを強化する)
            - [パフォーマンスチューニング](#パフォーマンスチューニング)
- [第3部](#第3部)
    - [8 章 ブレイクスルー](#8-章-ブレイクスルー)
    - [9 章 暗黙的な概念を明示的にする](#9-章-暗黙的な概念を明示的にする)
        - [概念を掘り出す](#概念を掘り出す)
            - [言葉に耳を傾ける](#言葉に耳を傾ける)
            - [ぎこちなさを精査する](#ぎこちなさを精査する)
            - [矛盾について熟考する](#矛盾について熟考する)
            - [文献を読む](#文献を読む)
            - [何度でも挑戦する](#何度でも挑戦する)
        - [それほど明白でない概念をモデル化する方法](#それほど明白でない概念をモデル化する方法)
            - [明示的な制約](#明示的な制約)
            - [ドメインオブジェクトとしてのプロセス](#ドメインオブジェクトとしてのプロセス)
        - [仕様](#仕様)
            - [仕様の適用と実装](#仕様の適用と実装)
                - [検証](#検証)
                - [選択](#選択)
                - [要求](#要求)
    - [10 章 しなやかな設計](#10-章-しなやかな設計)
        - [意図の明白なインターフェース](#意図の明白なインターフェース)
        - [副作用のない関数](#副作用のない関数)
        - [表明](#表明)
        - [概念の輪郭](#概念の輪郭)
            - [独立したクラス](#独立したクラス)
        - [閉じた操作](#閉じた操作)
        - [宣言的な設計](#宣言的な設計)
            - [ドメイン特化言語](#ドメイン特化言語)
        - [設計の宣言的スタイル](#設計の宣言的スタイル)
        - [攻める角度](#攻める角度)
            - [サブドメインを切り取る](#サブドメインを切り取る)
            - [可能な場合には、確立された形式主義を活用する](#可能な場合には確立された形式主義を活用する)
    - [11 章 アナリシスパターン](#11-章-アナリシスパターン)
    - [12 章 デザインパターンをモデルに関連づける](#12-章-デザインパターンをモデルに関連づける)
        - [ストラテジーパターン](#ストラテジーパターン)
        - [コンポジットパターン](#コンポジットパターン)
            - [なぜ FlyWeight パターンではない？](#なぜ-flyweight-パターンではない)
- [戦略的設計](#戦略的設計)
    - [14 章　モデルの整合性を維持する](#14-章　モデルの整合性を維持する)
        - [境界づけられたコンテキスト](#境界づけられたコンテキスト)
            - [境界つけられたコンテキスト内での分派を認識する](#境界つけられたコンテキスト内での分派を認識する)
        - [継続的な統合](#継続的な統合)
            - [コンテキストマップ](#コンテキストマップ)
        - [境界づけられたコンテキストの関係](#境界づけられたコンテキストの関係)
            - [共有カーネル](#共有カーネル)
            - [顧客/供給者の開発チーム](#顧客供給者の開発チーム)
                - [順応者](#順応者)
            - [腐敗防止層](#腐敗防止層)
            - [別々の道](#別々の道)
            - [公開ホストサービス](#公開ホストサービス)
            - [公表された言語](#公表された言語)
            - [モデルコンテキスト戦略を選択する](#モデルコンテキスト戦略を選択する)
                - [チームでの意思決定と、より上位層での意思決定](#チームでの意思決定とより上位層での意思決定)
                - [コンテキストに自らの身を置く](#コンテキストに自らの身を置く)
                - [境界を変換する](#境界を変換する)
                - [変更できないものを受け入れる](#変更できないものを受け入れる)
                - [外部システムとの関係](#外部システムとの関係)
                - [設計中のシステム](#設計中のシステム)
                - [別のモデルで特殊な要求を満たす](#別のモデルで特殊な要求を満たす)
                - [デプロイ](#デプロイ)
                - [トレードオフ](#トレードオフ)
                - [すでにプロジェクトが進行中の場合](#すでにプロジェクトが進行中の場合)
            - [変換](#変換)
                - [コンテキストのマージ：別々の道 -> 共有カーネル](#コンテキストのマージ別々の道---共有カーネル)
                - [共有カーネル　-> 継続的な統合](#共有カーネル　--継続的な統合)
                - [レガシーシステムを段階的に廃止する](#レガシーシステムを段階的に廃止する)
                - [公開ホストサービス　-> 公表された言語](#公開ホストサービス　--公表された言語)
    - [15 章　モデルの整合性を維持する](#15-章　モデルの整合性を維持する)
        - [コアドメイン](#コアドメイン)
        - [汎用サブドメイン](#汎用サブドメイン)
        - [ドメインビジョン声明文](#ドメインビジョン声明文)
        - [強調されたコア](#強調されたコア)
            - [蒸溜ドキュメント](#蒸溜ドキュメント)
            - [フラグ](#フラグ)
        - [凝集されたメカニズム](#凝集されたメカニズム)
        - [隔離されたコア](#隔離されたコア)
            - [隔離されたコアを作るタイミング](#隔離されたコアを作るタイミング)
        - [抽象化されたコア](#抽象化されたコア)
    - [大規模な構造](#大規模な構造)
        - [進化する秩序](#進化する秩序)
        - [システムのメタファ](#システムのメタファ)
        - [責務のレイヤ(あとで確認)](#責務のレイヤあとで確認)
        - [知識レベル](#知識レベル)
        - [着脱可能のコンポーネントフレームワーク](#着脱可能のコンポーネントフレームワーク)
        - [構造による制約をどの程度厳しくすべきか？](#構造による制約をどの程度厳しくすべきか)
        - [ふさわしい構造へのリファクタリング](#ふさわしい構造へのリファクタリング)
    - [戦略をまとめ上げる](#戦略をまとめ上げる)
- [参考文献](#参考文献)

<!-- /TOC -->


# 第1部

## 知識を噛み砕く
効果的なモデリングを行う方法は以下の5つ

- 早い段階でモデルと実装を結びつける(荒削りではあるが早い段階でプロトタイプを作成することにより、実装の全体を俯瞰できるようになり、それを用いて改善を続けていく下地ができる。)  
- モデルに基づいて言語を洗練させる(業務に携わる人がモデルに出現する単語のみで会話できるようにする。)  
- 知識（ここでいう知識とは各オブジェクトがもつルールのことである) 豊富なモデルを作成する  
- モデルを蒸留する(実装において重要な部分をモデル化し、そうでないところは省略する)  
- ブレーンストーミングと実験を行い、モデルを洗練させる  

### 知識豊富なモデル
アプリケーション層に判断のロジックを実装するのではなく、判断のメソッドを実装したモデル(ポリシーオブジェクト)を作成する。そうすれば、モデルと実装が一対一で結びつく。  
要するにドメインオブジェクトに判断のロジックを持たせることをいっている？

### 深いモデル
モデリングを行う上では決して表層的な部分のみをみてはいけない、システムをあらゆる視点から観察し、どの観点がそのシステムの本質を端的に表しているかを確認する必要がある。(p1067)
例えば、荷物の配送をモデリングする際には、表面的にこの業務活動を捉えると、荷物がどの地点からどの地点まで移動するかを関心におきモデリングが行われることが予想されるが、実際には配達の過程でどの業者からどの業者に配達の責任が委譲されるかを関心においた方がモデリングとして適切なこともある。  
とりあえず他に適切なモデルが存在するかどうかを考え続けることが大切である。

### ユビキタス言語
モデルを言語の骨格として扱う。もし現状使用している言語に問題があって修正を行う場合は、それに基づいてコード(メソッド、クラス、モジュール)をリファクタリングする。ユビキタス言語の変更はモデルの変更である。ドメインエキスパートはドメインについての理解を伝えるには使いにくかったりふさわしくない用語に関しては意義を唱え、開発者は曖昧さを排除するために言語の不整合に関して気にするべきである。  
業務シナリオをモデリングする際に、そのモデリングを声に出して表現してみる。そして、より簡単にいう方法を見つけ、そのモデルをコードに反映させる。

### ドキュメントと図
ソースコードが業務活動をもっとも端的に表している第1級ドキュメントであるべきである。そうすることにより、エンジニアはソースコードを綺麗に整理された状態を保とうとするからである。他の資料はソースコードの補足的な立ち位置となる。

### 説明のためのモデル
オブジェクトモデルが必ずしもわかりやすいとは限らない。何故ならば、オブジェクトモデルは必要な要素を最小限に止めるという関心が存在しているためである。そういった場合は説明用のモデルを別途用意した方が良い。

## モデルと実装を結びつける

### モデル駆動設計
分析フェーズでモデルを構築しそれを設計に反映していく方針をとるプロジェクトが存在するが、分析フェーズで構築されたモデルがそのまま設計に役立つとは限らない。何故ならば、分析フェーズで構築されたモデルは設計を行う際に引き起こされる問題を考慮していないからである。したがって、分析と設計の間に大きな亀裂が生じることとなり、プロダクトを良い方向に向かわせることは難しくなってしまう。  
それを回避するため、モデル駆動設計では分析と設計の双方で利用できるモデルを探しだすことを目的としている。分析と設計を一つのサイクルで回し、多くの議論やリファクタリングを経て適切なモデルを構築していく。

### モデリングパラダイムとツールによるサポート
オブジェクト指向のプログラミング言語が強力なのは、コードで概念的な存在であるモデルというものを表現できることにある。

### 骨格を見せる
分析と設計でモデルに差異が存在するのも問題だと述べたが、それと同じくユーザが実際に触れるモデルとオブジェクトモデルに差異が生じてもそのアプリケーションは扱いづらいものとなる。IEの例をあげると、IEの「お気に入り」というオブジェクトの実態というのはファイルであり、使用できない文字が存在する。ユーザがお気に入りを変更する場合に使用できない文字を指定すると、エラーが発生するか、それとも使用できない文字は排除されて保存される。どちらにしてもユーザ体験としてはよろしくない。であれば、初めからお気に入りはファイルの形態をしているということをユーザに周知した方が、ユーザ側は対処というアクションを行うことができる。

### 実践的モデラ
モデリングを行う技術的な人間は一定時間コードを触れる必要がある。コードの変更に対して責任を負う人はコードを通してモデルを表現することを習得しなければならない。

# 第2部
この部ではモデル駆動設計の構成要素について触れる。

## ドメインを隔離する

アプリケーションへの理解を促進させるために、モデルは一つの体系としてまとまっているべきである。決して複数のオブジェクトが存在する中でモデルの要素を拾い上げるというような理解のプロセスはとってはならない(それは直感的ではない）。　　

###  レイヤ化アーキテクチャ
レイヤ化アーキテクチャを用いてアプリケーションをプレゼンテーション層、アプリケーション層、インフラストラクチャ層、ドメイン層に分けることによって関心事を分離させることで、ドメイン層はドメインモデルを表現するという責務に集中させることができる。

#### レイヤを関係づける
アプリケーション層でインフラストラクチャ層が提供するサービスを呼び出す場合は、そのサービスはインターフェースを介して呼び出すように設計する。こうすることにより、アプリケーション層は疎結合を保つことができ、本来のアプリケーション層の責務に集中することができる。

#### アーキテクチャフレームワーク
インフラストラクチャ層の役割は、アプリケーションから呼び出されるサービスの提供に加えて、その他の層で使用するサービスの提供や、複数の層を関係づける「アーキテクチャフレームワーク」の側面が存在する。この機能を実現するために様々なフレームワークがよく用いられるが、フレームワークはオブジェクトに対していくつかの制限を設けるものもある(特定のクラスの継承や独自の命名規則を強制させる)ので、必要十分な機能のみを選んで使用することが望ましい。

### ドメイン層はモデルが息づく場所
ドメイン駆動設計の特徴は、ドメインロジックを実装したドメインオブジェクトをドメイン層に隔離することでプログラムの他の関心事と隔離させることにある。

## ソフトウェアで表現されたモデル
モデルを表現するパターンは主にエンティティ、値オブジェクト、サービスの3つである。それぞれの機能は以下の通り。  

|  パターン  |  機能  |
|:--:|:---|
|  エンティティ  |  連続性と一意性を持ったオブジェクト  |
|  値オブジェクト  |  状態を記述するオブジェクト  |
|  サービス  |  クライアントの要求に応じて何かの処理を行う  |

これに加えてモジュールという概念も存在する。のちに説明する。  
これらのパターンを意識することにより、設計において道を踏み外す可能性を減らすことができる。

### 関連
オブジェクト間の関連は複雑にしない方が良い。例えば、双方向の関連は双方のオブジェクトについて理解をしなければならず、加えて理解のベクトルが直感的には理解しにくい。  

関連をシンプルにする方法は3つ存在する。  
1. 関連の方向を限定させる(双方向の関連を除去する)。  
2. 関連の限定子を追加して、多重度を減らす(1対多のオブジェクトを何か一意に定める識別子で管理する)。  
3. 本質的ではない関連を除去する。

### エンティティ(参照オブジェクト)
オブジェクトには同一性と属性の2つの側面が存在する。エンティティとは、その中でも同一性が担保されたオブジェクトのことを指す。同一性で識別されるエンティティは、その同一性を第一とし、設計もそのことを反映させる必要がある。加えて何を持ってして同一であるかの判断を行うには、一般的に使用されている識別子を用いる方法もあれば、プロジェクトで定めたルールを適用するという方法も存在する。例えば、新聞は、発行日付、新聞の名前、都市名の3つで一意に特定できる。

### 値オブジェクト
値オブジェクトとは、エンティティと異なり、同一性を持たないオブジェクトのことをさす。そのオブジェクトが「何」を意味しているのかのみを表現し、「誰」や「どれ」であるかを求められない。

### サービス
エンティティや値オブジェクトにドメインロジックの業務を押し付けて、自分自身はそれらを用いた総合的な操作のみを行うオブジェクトをサービスと呼ぶ。優れたサービスには 3つの特徴がある。  

1. ロジックがエンティティや値オブジェクトの一部ではない。  
2. インターフェースとして定義されている。  
3. 操作に状態がない。

また、ドメイン層にサービスクラスが存在することになると、アプリケーション層とドメイン層の両方にサービスクラスが存在することになるが、その線引きは処理の内容によって行う。例えば、銀行システムで入出金の情報をスプレッドシートなどのファイルに書き出す処理は直接の業務ロジックとは関係がないため、アプリケーション層のサービスクラスで実装する。しかし、資金振替という処理は業務ロジックそのままであるから、ドメイン層のサービスクラスで実装する。

### モジュール
ドメインモデルを物語とするならば、モジュールは物語の章である。モジュールを構成するメリットとしては以下の2つ。

1. モデル全体に圧倒されることなく、モジュール単位でロジックの詳細を理解することができる。  
2. モジュールの詳細を無視した上でモジュール間の関係を理解して、業務の全容を把握することができる。

### モデリングパラダイム
省略

## ドメインオブジェクトのライフサイクル
オブジェクトが生成され、削除されるまでのライフサイクルは様々な条件が存在することで複雑になる場合がある。そういったライフサイクルの管理には2点の課題が存在する。

1. ライフサイクルを通じて整合性を保たなければならない。  
2. ライフサイクルが複雑であったとしてもモデルが侵食されないようにしなければならない。

この課題に対応するために、3つの設計パターンを紹介する。

|  パターン  |  役割  |
|:--:|:---|
|  集約  |  オブジェクトの所有権と境界を定義し、モデルを引き締める。整合性を保つという点で重要  |
|  ファクトリ  |  ライフサイクルの始まりのフェーズで複雑なオブジェクトや集約を生成したり再構築を行う。この際カプセル化を行い、外部には必要最低限のリソースのみを提供する。  |
|  レポジトリ  |  永続化されたオブジェクトにアクセスする手段を提供し、アクセスを行うためのインフラストラクチャをカプセル化する。  |

### 集約
集約とは関連するオブジェクトの集まりであり、集約の単位でデータの変更が行われる。集約を構成するものとしてはルートというエンティティと集約の内部に何が存在しているかを示す境界が存在し、外部のオブジェクトはルートを介してデータ操作を行うことができる。集約の内部に存在するエンティティは同じく内部に存在するオブジェクトの参照を持つことができる。また、内部のオブジェクトの同一性は内部でのみ識別できれば良い。例えば、自動車をモデルと捉えると、自動車自体は同一性を担保する必要があるが、自動車に付随されるタイヤや位置情報などは同一性の担保は求められない。この場合自動車がルートとなり、タイヤや位置情報は境界内に存在するオブジェクトとなる。’  

集約の特性としては以下が存在する。  

1. 集約のルートエンティティは同一性を保持しており、またその集約における不変条件を用いてチェックを行う責務を持つ。  
2. 外部のオブジェクトは境界内部のオブジェクトにはアクセスできない。アクセスするときは決まってルートエンティティを介して行わなければならない。さらに、外部オブジェクトはルートエンティティから返されるオブジェクトへの参照を持つことはできない。  
3. 境界内部のオブジェクト同士で参照を持つことは可能である。  
4. 内部のオブジェクトの変更がコミットされた場合は、ルートエンティティの不変条件を全て満たしていなければならない。  
5. ルートエンティティが削除された場合は、境界内のオブジェクトも削除する必要がある。これはガベージコレクションの機能が存在すれば容易である。  

### ファクトリ
複雑な複合オブジェクトを生成する場合、ドメインオブジェクトで生成する場合は、そのオブジェクトを生成した後に行う処理とは分離しておくのが良い(複雑なオブジェクトの場合、生成処理そのものが業務ロジックと呼ぶにふさわしくなく、そのオブジェクトの業務ロジックへの関心が薄れてしまう恐れがあるから)。  
しかし、生成処理をアプリケーション層で実装してしまうと、途端にアプリケーション層とドメイン層は疎結合ではなくなる。また、アプリケーション層に実装すべき内容ではないし、リファクタリングも容易にはすまなくなる。  
したがって、それを解決するため、複雑なオブジェクトを生成するファクトリというオブジェクトを定義する。オブジェクトの生成をカプセル化し、全てインターフェースとして提供すること、ファクトリを使用するクライアント側は、ファクトリから提供されるオブジェクトの具象クラスを知ることがないようにすること。

ファクトリが満たす要件としては以下の2点が存在する。  
1. ファクトリは一貫した状態のオブジェクトしか返してはいけない。  
2. ファクトリは具象クラスを返すのではなく、要求される型に応じて抽象化しなければならない。

#### ファクトリとその場所を選択する
1. 既存の集約に新たに要素を追加する場合は、ファクトリはその集約のルートエンティティで実装する。  
2. あるオブジェクトの生成に密接に関わっているオブジェクトで実装する。そうすることで、オブジェクト間の関係を伝えることができる。

#### コンストラクタがあれば良い場合
わからなかった。

#### インターフェースを実装する
1. 返す値はアトミックでなければならない。  
1回の操作で制約をクリアした完全なオブジェクトを生成する。また、制約を違反したことによる例外のスローは標準的な対応を決めておく。  

2. ファクトリはその引数と結合する
ファクトリに渡す引数となるオブジェクトはよく吟味する。何故ならば、いくつもの参照をもつオブジェクトを引数に選ぶと、ファクトリが処理している途中で予期しない箇所にも更新が行われる可能性があるからである。一番安全なオブジェクトは、参照を持たない最下位層のオブジェクトである。

#### 不変条件のロジックはどこに置くべきか？
ファクトリにはオブジェクトに一貫性を持たせるためにそのオブジェクトに制約を課すことが求められるが、その制約によるチェック処理はどこで実装すべきかは議論が分かれるところである。極論生成したオブジェクト自身がその制約を持っているのが最善であることもある。しかし、ファクトリは生成するオブジェクトの内部構造を熟知している。加えて生成したオブジェクトがアクティブである間その制約によるチェック処理を行わないのであれば(オブジェクト生成時のみその制約が適用されるのであれば)、チェック処理はファクトリで実装した方が良い。

#### エンティティファクトリと対値オブジェクトファクトリ
値オブジェクトは不変であるので値オブジェクトファクトリは、値オブジェクトを生成する場合には完全なオブジェクトを生成する必要がある。これに対しエンティティファクトリは、本質的な情報のみを生成時に受け取り、それに基づいて集約を構成する。そしてそのあとに詳細部分を追加していく。

#### 格納したオブジェクトを再構成する
生成ではなく再構成を行うファクトリは以下の2点を考慮する。

1. 再構成を行う場合は、同一性を担保するためにオブジェクトの識別する一意の情報は更新しないようにする。  
2. 再構成を行なった場合、万が一ファクトリが課す制約に違反していた場合の対応を考えておく。

### リポジトリ
オブジェクトが何か処理を実行するためには、他のオブジェクトの参照を持たなければならない時がある。その場合、どんどん参照を追加していくとモデルが複雑になってしまい、実装を続けていく上で混乱する事態が発生する。また、オブジェクトがデータベースなどの永続されたデータソースに対して処理を依頼する場合、データソースにアクセスするためのインフラストラクチャのコードを実装しなければならない。この実装をクライアント側で行おうとすると、インフラストラクチャの内容が濃いコードに入り込むことになってしまい、クライアントが何を行おうとするのかを理解するのに労力がかってしまうことがある。　　
　　
前者の問題は、集約を用いて参照できるオブジェクトを制御することで解決できる。後者の問題はデータベースアクセスの技術と戦略をカプセル化するリポジトリというオブジェクトを定義することによってクライアントはユビキタス言語を用いたデータの取得や更新処理をそのリポジトリに依頼するだけでよくなり解決することができる。  

リポジトリのメリットとしては以下の4点。
1. クライアントに対して永続化されたオブジェクトを管理するシンプルなモデルを与えることができる。  
2. 永続化されたオブジェクトにアクセスするという技術的な実装内容をクライアントからもドメインオブジェクトからも隔離することができる。  
3. どのように永続化されたオブジェクトにアクセスするかという設計上の指針を伝えることができる。  
4. テストを実行する上で、モックを用意するのが容易となる。  

#### リポジトリに対して問い合わせる
フレームワークを用いてリポジトリを一般化する場合は、ある仕様のパターンに基づいたクエリを使用する。

#### クライアントのコードはリポジトリの実装を無視するが、開発者はそうではない
リポジトリはクライアントからみて永続化されたオブジェクトに対してアクセスを行う処理をカプセル化するが、開発者はカプセル化されている内容に関して理解していなければならない。例をあげると、とある検索処理を行うリポジトリがメモリ不足になるという事態が発生した。これはリポジトリが全てのレコードをインスタンスとして生成してそれらに対して検索をかけていたためである。これは、リポジトリの実装を理解していなかったから生じた現象である。

#### リポジトリを実装する
リポジトリの実装方針としては以下

1. 型を抽象化する  

2. クライアントから切り離す利点を生かす  
テストや性能比較が容易に実行できるようになる  

3. トランザクション制御はクライアントに委ねる  
リポジトリ側でデータベースに対してコミットを行わず、コミットの実行はクライアントに委ねる。なぜなら、クライアント自身がコミットのタイミングを決定したいというモチベーションがあるからである。 

#### フレームワークの範囲内で作業する
ドメイン駆動設計とフレームワークの似通った点がないか探し、存在しない場合は対立せずにフレームワークの詳細な機能を捨て去り、必要な部分のみを使用する方が結果的にはドメイン駆動設計の体裁を保つことができる。

#### ファクトリとの関係
リポジトリが外部のデータソースにアクセスしてオブジェクトを生成することがあるが、オブジェクトの生成はファクトリに移譲したほうが個々の役割に集中できる。

#### 関係データベースに合わせてオブジェクトを設計する
関係データベースに格納されているデータをオブジェクトに変換するマッピングは透過的でなければならない。データベースをデータの格納先に採用する場合は、以下の2点に気をつける。  

1. データモデルとオブジェクトの構造をかけ離れたものにしてはならない。マッピングが容易となるなら、無理に正規化することは避けること。  
2. 不変条件を満たすために、外部のプロセスからのデータベースへのアクセスは避けること。

## 第7章
この章ではこれまで述べてきたモデル設計のパターンを応用して実際に実装を行なっていく。

### 貨物輸送システムの導入
- 貨物には複数の顧客が紐づいている(荷物受取人、荷出し人、etc ...)  
- 配送の目標が定義される(~ 日以内に ~ へ配送される etc ...)  
- 目標は仕様に基づいて適切な輸送機器移動によって達成される  

|  オブジェクト  |  意味  |
|:--:|:---|
|  荷役イベント  |  貨物船への積み込みなどの貨物に関して行われる個別のアクション  |
|  配送仕様  |  配送の目標を定義するもの。少なくとも荷出し地と配送日時を含む。 |
|  役割  |  顧客と貨物間の関係における顧客の役割。荷送人、荷受人 etc...  |
|  輸送機器移動  |  輸送機器による貨物のある地点からある地点までの移動  |
|  配送記録  |  貨物に起こったこと  |

配送仕様は貨物オブジェクトに含めることもできたが、以下の理由で個別にオブジェクトとして定義した。  
- 貨物オブジェクトに含めると、配送仕様の詳細な内容まで貨物オブジェクトが責任を持つことになり、モデル自体が混沌とする。  
- 別途オブジェクトで表現することにより、モデルを説明する際に、配送仕様の概念が明らかになり、詳細内容を確認しなくてもなんとなく理解することが可能となる。うまくカプセル化ができる。  
- 表現力が豊かになる。例えば配送手段が決まっていなくても目標を達成しなければならないということを伝えることができる。

### ドメインを隔離する：アプリケーションの導入
実装するアプリケーションは以下の3つ　　
1. 貨物追跡問い合わせアプリケーション  
2. 予約アプリケーション  
3. イベント記録アプリケーション(追跡問い合わせで検索される情報を提供する)　　

### エンティティと値オブジェクトを区別する
配送記録は貨物と一対一で関連づいているので、それ自身は同一性を保持していない。したがって値オブジェクト。

### ドメインの関連を設計する
今回は貨物輸送システムの開発であるから、貨物オブジェクトに輸送の概念を追加してそれをメインに据えた関連を構築する。
顧客が関連する貨物に対して関連を持っていると、リピータの場合関連する貨物が多くなる。さらに、今回作成するアプリケーションの関心は顧客ではなく貨物である。  
このことを踏まえると、荷役イベントと輸送機器移動の関連は、貨物を関心におくことから、 荷役イベント -> 輸送機器移動という関連となる。  
AとBの関連を考えるときには、そのモデルが「Aから辿ってBを導き出す」のが自然なのかそれとも逆が自然なのかを考えることで、関連を一方向にすることができる。

### 集約の境界
貨物を集約ルートのエンティティとして辿るのが自然なオブジェクトは、配送記録、配送仕様の2つ。  
荷役イベントも貨物から辿るのが自然だと考えることもできるが、これは2つの観点から貨物の境界内部に含めるかどうかが議論の別れる余地のあるものである。  
1. 配送記録から荷役イベントを参照する場合、それは「貨物に対する荷役イベント」となり境界内部に含める方が適切である。  
2. 荷役イベントを特定の貨物と関連づけずに「とある輸送機器移動に対して荷積みと準備を行うアクション」と捉えた場合に関しては境界の外部に位置するものである。  
今回は後者の観点実装するので、荷役イベントは独自の集約ルートとして扱う。

### リポジトリを選択する
アプリケーションの機能要件からリポジトリを考える。今回は以下の4つ。

1. 予約の際に顧客を選択する際に使用される顧客レポジトリ　　
2. 貨物の荷出し地を選択する際に使用される位置レポジトリ  
3. 貨物の追跡を行う際に使用される輸送機器レポジトリ
4. どの貨物が荷積みされたかをシステムに知らせる貨物レポジトリ　　

### シナリオをウォークスルーする
実際にシナリオを考えてみてモデルが適切かどうかを確認する必要がある。

#### 荷出し地の変更
この場合配送仕様に存在する荷出し地の値が変更になる。配送仕様は値オブジェクトなので、変更前のオブジェクトは廃棄して新しく Setter を用いて設定し直す。

#### リピータへの対応
リピータは同じ注文を行う傾向があるので、以前に発注された貨物を新しく注文された貨物のプロトタイプとして扱いたい。　　
貨物はエンティティであるから、そのままコピーするのは問題がある。したがって、以下の方針にしたがってコピーを行う。  
1. 配送記録は新しく生成する。  
2. 新しい貨物でも顧客の役割は変わらない可能性が高いので、顧客はコピーする。しかし、値そのものではなく、参照を以前のものと同じにしておく。これは顧客が貨物の集約境界の外部に位置するからである。  
3. 貨物IDは新しく発行する。
4. 貨物の集約境界内のものは全てコピーする。

### オブジェクトの生成

#### 貨物用のファクトリとコンストラクタ
貨物は配送記録を参照しており、配送記録は荷役イベントを保持している。そして荷役イベントは貨物を参照している。したがって貨物と配送記録は双方向の関連になっているので、それらのオブジェクトを生成する際は同時に生成しなければならない。

#### 荷役イベントを追加する
配送記録が更新されると、荷役イベントも更新され、さらに荷役イベントも貨物への参照を取得しなければならない。

### リファクタリングのために立ち止まる
「荷役イベントを追加する」の項で得られた課題としては、荷役イベントが更新されると、整合性を維持するためにその荷役イベントのコレクションを保持している配送記録オブジェクトも更新を反映しなければならないという点であった。さらに配送記録が貨物集約の内部モデルであることがこの課題をさらに難しくしている。これを避けるために、配送記録に荷役イベントのコレクションを持たせるのではなく、荷役イベントのリポジトリを用意して、配送記録にはそのリポジトリから自身に関連するイベントの集合を取得できるようなクエリのみを持たせるという方法が考えられる。リポジトリを作成する他のメリットとしては、荷役イベントの集合に対して、クエリさえ用意すれば、自分で設定した検索条件に合致した荷役イベントの集合を取得できることである。

### 輸送モデルにおけるモジュール

![image](https://user-images.githubusercontent.com/40063377/66277853-f7d7a780-e8de-11e9-9208-3254a246604a.png)  

モジュールを構成する際に大切なことは、モジュールを構成しているオブジェクトが高凝集であり、他の人々にも伝えやすいようにすることである。

### 新機能を導入する：配分チェック

#### 2つのシステムを接続する

#### モデルを強化する
外部システムの連携の際には、外部システムで使用されている用語は極力使用せずに、自分たちの業務アプリケーションに適した用語を新たに設定することが大切である。外部アプリケーションと自分たちのアプリケーションの差異を埋めるために中間にサービスクラスを用意する。例えば、このサービスクラスは自分たちが使用している用語(本書ではエンタープライズセグメント)をそれに対応した外部システムで使用されている用語に変換する役割を担っている(腐敗防止層)。

#### パフォーマンスチューニング

# 第3部
良いドメインモデルを構築するには継続的なリファクタリングを行うことが必要不可欠である。ここでいうリファクタリングとは、コードがどんな処理を行なっているかを開発者が理解しやすいように作り変えていくことに加え、何故それを行うのかということを理解した上で、ドメインエキスパートが想定している処理を実際のコードに落とし込んでいくことである。 

## 8章 ブレイクスルー

ドメイン設計に関するブレイクスルーを起こすには以下を実行する。  
1. 知識を噛み砕いて、強固なユビキタス言語を構築する。  
2. ドメインの概念を探求して、それをモデル化する。  
3. そのモデルをしなやかな設計になるように改良する。  
4. モデルを蒸留する。  

## 9章 暗黙的な概念を明示的にする

深いモデルは、荒削りではあるが、早期にモデルを定義し、イテレーションを通してモデルを改良していくことで得られる。改良のイテレーションを行うためには、チームメンバーと話す過程で説明がぎこちない箇所やドメインエキスパートとの言動が矛盾している箇所に気づき、それに関するドメインの資料を読んで大量の実験を行う必要がある。

### 概念を掘り出す
#### 言葉に耳を傾ける
ユーザやドメインエキスパートの言葉に耳を傾けて、定義したユビキタス言語以外の単語が出現しているかどうかを確認する。そしてその単語がモデルに対して新たな概念を与えるきっかけを作ることになる。  

#### ぎこちなさを精査する
説明するのが難しい処理だったり、仕様変更が重なり処理が複雑なモデルを設計する場合はドメインエキスパートに調査に参加してもらったり、自分たちが考えたアイディアを精査してもらった方が良い。

#### 矛盾について熟考する
同じ事象に関してドメインエキスパートが異なる複数の解釈を用いることがある。この場合我々の認識が足りていない場合がありドメインモデルを磨き上げるチャンスとなる。両方の解釈を同じ現実にどう適用できるのかは考えることで明らかになる可能性がある。  

#### 文献を読む
ドメインエキスパートに助力を求めるのに加え、該当分野の文献を読むことで、深いモデルを得ることがある。もちろん両方に取り組むことが可能である。また、開発者視点としては他のドメイン駆動設計の経験がある人の文献を読むことで、モデルに対して新たな知見を与えることができる。  

#### 何度でも挑戦する
深いモデルを得るためには、やはり変更を重ねるしか他ない。変更を重ねないモデルは品質としては低いものとなる。

### それほど明白でない概念をモデル化する方法

オブジェクト指向パラダイムによって、概念的な存在のものでもオブジェクトにモデル化することが可能となったが、そういった概念的なものをモデル化する上での指針を紹介する。

#### 明示的な制約
例を挙げると、バケツに注ぐ水の量が、現在バケツに入っている水量と合わせて容量を超えていないかどうかを判断する処理をバケツクラスのメソッドとして定義する。  

制約を独立したメソッドとして切り出すメリットとしては以下の2点  
- メソッドとして独立させることで、制約単体の議論を行う余地が与えられる。  
- メソッドとして切り出しておけば、制約そのものが複雑になったとしても呼び出し側をシンプルな構造に保つことができる  

#### ドメインオブジェクトとしてのプロセス
サービスはプロセスを明示的にしつつも内部の処理をカプセル化してくれる。明示すべきプロセスと隠蔽すべきプロセスを判別するには、ドメインエキスパートが話題に挙げるものか、コンピュータのシステムとしての側面が大きいのかどうかで判断する。

### 仕様
ビジネスルールはエンティティや値オブジェクトの責務に合致しないことがしばしばある。かといってアプリケーション層で実装するのはもっときまりが悪い。ドメインがビジネスロジックを体現しなくなるからである。  
解決策としては、ビジネスルールを体現するオブジェクトを作成する。とあるオブジェクトを対象にしてそのオブジェクトに関する判断をメソッドとして集約させた述語的な値オブジェクトを作成する。これが仕様である。ここではその仕様を実装するパターンを紹介する。

#### 仕様の適用と実装

仕様を定義するメリットとしては、異なるように見えるアプリケーションの機能を統一することである。
モデルを実装する際、以下の3つの目的がある場合は仕様を実装する。

1. 検証: オブジェクトが何らかの要求を満たしているか、何かしらの目的のための準備が整っているかを検証する。  
2. 選択: 集合から何かしらの条件を満たしたものを選択する。  
3. 要求: クライアントからの要求を満たしたオブジェクトを生成する。

##### 検証
検証は単にオブジェクトに対してある条件を満たしているかどうかを検証するメソッド(isXXX)を実装すれば良い。

##### 選択
集合に対して何らかの条件を満たすオブジェクトを返却する処理を実装する。選択に関していうと集合は大抵外部のデータソースで保持されていることがほとんどなので、仕様オブジェクトとリポジトリの構成は気をつけなければならない。O/Rマッピングを使用すればある程度気にしなくても良いが、使用しない場合はリポジトリにクエリの情報を保持しておき、どのクエリを使用するかは仕様に委ねる形で実装する。

##### 要求
要求を満たすかどうかの判断のロジックはインターフェースを実装したクラスで実装し、実際に要求を満たしたオブジェクトを用いた処理はサービスクラスに移譲させる。

## 10章 しなやかな設計

しなやかな設計とは、プロジェクトを円滑に進めるために、開発者が楽しく、そしてソースコードの変更が容易にできる設計のことを指す。  
しなやかな設計、それすなわちシンプルな設計であるが、それを実現するには2つの視点が欠かせない。一つ目は、ドメインオブジェクトを利用してアプリケーション層を実装するクライアント開発者の視点である。クライアント開発者は疎結合であるドメインオブジェクトを用いてシンプルにシナリオを実現する必要がある。もう一つはドメインオブジェクト開発者視点である。これはドメインオブジェクトを変更容易にし再利用可能な設計を実現する必要がある。またクライアント開発者が考えているモデルとドメインオブジェクト開発者が考えているモデルを一致させる必要がある。

### 意図の明白なインターフェース
クラスやメソッドの名前が適当だと、クライアント側はせっかくカプセル化したオブジェクトをどう使用していいか分からないという事態に陥るので、クラスやメソッドはその役割を表現したような命名を行うこと。

### 副作用のない関数
プログラムにおける操作には2種類存在する。それはクエリとコマンドである。クエリは情報を取得するだけでモデルに関しては何も変更しない操作を指し、コマンドは実行することによりモデルに何らかの変更を強制する操作である。このモデルの変更に関しては、我々があずかり知らぬ部分も変更されることがある。これを副作用と呼ぶ。副作用はなるべく起こさないことが望ましいが、そのためには副作用を生じさせないステートレスな関数を実装する、コマンドはクエリと厳密に分離させる、複雑なロジックはその値オブジェクトにメソッドとして実装し、副作用をそのクラスに止める、の3つがあげられる。 

### 表明
副作用が発生する条件と、そのクラスの集約の不変条件を宣言する。どういったケースで副作用が発生するのかを明示しておくだけでクライアント開発者は作業が進めやすくなる。また不変条件そのクラスの特性を表しているため、モデルの理解に繋げることができる。表明がうまくソースコードで表現できない場合はテストでカバーする。

### 概念の輪郭

#### 独立したクラス
最も入り組んだ処理を独立したクラスへ分解するように試みる。大抵は、つながりの多いクラスで保持されている値オブジェクトをモデル化することで実現できる。

### 閉じた操作
関数の返り値の型が引数と同じ型にできる場合は、なるべくそのような設計にする。それにより、他の概念の依存関係を導入することなく業務ロジックを実現できる。

### 宣言的な設計
モデルが理解しやすいようなプログラムをコーディング際には意図が明白になるように仕様の宣言が必要不可欠である。そういった宣言は場合にコンパイル時に自動生成することもできるが、欠点が2点存在する。  
- その機能の表現力が豊かではない。  
- 手動で仕様を変更しなくなるため、イテレーションのサイクルを損なってしまう。  

#### ドメイン特化言語
こういった宣言を効果的にするためには、ドメイン特化言語を使用すると良い。ドメイン特化言語 (Domain Specific Language) は、あるモデルに対する知識や用語を用いて事象を表現できるプログラミング言語のことを指す。

### 設計の宣言的スタイル
ここで重要なのは、単純な処理を組み合わせて複雑な処理を実現するという点である。それを実現するために、インターフェース側では、閉じた操作の思想に基づいたメソッドを実装することを要求する。コンテナの特性を AND や NOT で定義できるようになることは宣言的な設計となる。

### 攻める角度
この項では巨大なプロジェクトにおいて、どのような過程を経てしなやかな設計にしていくのかを説明する。

#### サブドメインを切り取る
最初からプロジェクト全体に対して設計をし直すのは現実的ではないので、まずは一部を切り出して取り掛かること。

#### 可能な場合には、確立された形式主義を活用する
確立された形式主義の例には数学があげられる。多くのモデルは数学の側面を持っており、数学は様々なルールを結合することができ、理解するのも容易である。

## 11章 アナリシスパターン

アナリシスパターンとは、過去のドメイン駆動開発から得られた知見から作られた設計のパターンである。ドメイン駆動開発を行なっているので、ソースコードが資料となるから、流用することが可能である。このパターンはあらゆるドメインにおいて役立つものものもあれば、1つのドメインにしか適さないものもある。  

## 12 章 デザインパターンをモデルに関連づける
この章では、デザインパターンとドメインパターンの違いについてのべる。

### ストラテジーパターン

ストラテジーパターンはStrategy インターフェースを実装したクラスを複数作成し、状況に応じてその実装クラスを使い分けるパターンである。  
このデザインパターンがドメインモデルに与える影響について述べる。仮にモデルを体現したプロセスをストラテジーパターンによって実装することを考えると、それは業務ロジックを体現したモデルを使い分けるということになる。適切なモデルを選択して処理を行うことは、そのモデル自体の複雑性も相まってロジックを複雑にする感応性がある。  
ストラテジーパターンを使用する場合は、プロセス自体をストラテジーパターンに適用するのではなく、プロセスの一部の処理で変化しやすい処理に対して適用する。  
この項では輸送サービスにおける経路選択を行うロジックで、どの経路が最適かを決定するプロセスにストラテジーパターンを採用している(一番金額的コストが低いのか、一番距離が短いのか etc)

### コンポジットパターン
あるオブジェジェクトが同じオブジェクトを保持するデザインパターン。例えば、ファイルシステムはディレクトリの直下にまたディレクトリを配置することができるが、これはコンポジットパターンである。マトリョーシカ。　　
コンポジットパターンで実装されているオブジェクトは以下の問題点を抱えている。
- 共通する振る舞いを各層で繰り返す  
- 構造が複雑になりやすい  
- オブジェクトのネスト構造の柔軟性が低い(同じレベルに位置するコンテナには干渉できない、レベル数が限定されている etc...)  

輸送サービスについてこのパターンを適用することを考えると、輸送経路は複数の輸送経路セグメントから構成され、さらに輸送経路セグメントは複数の工程で構成される。この輸送経路セグメントと工程オブジェクトは、どちらも経路インターフェースを実装しており、経路インターフェースにはその経路に対する操作(荷受け、荷出し、経路構造を辿る)が定義されている。  

#### なぜ FlyWeight パターンではない？
FlyWeight は複数のクラスの間であるオブジェクトを共有するパターンであるが、これが適用されるのは値オブジェクトの集合に対してのみであって、変化し続けるエンティティには適用できない。変更による影響が共有している全てのクラスに及ぶためである。

# 戦略的設計
コンテキスト、蒸留、大規模な構成

## 14 章　モデルの整合性を維持する
この章では、モデルの適用範囲や関係性を認識し、伝達するためのテクニックを紹介する。

### 境界づけられたコンテキスト
モデルを適用する範囲(スコープ)を定義しておかないと、ある箇所で複数のモデルが適用されることとなり、コードがバグの温床になることがある。また、複数のモデルが適用されているために、コードを読む別の人は理解しにくくなる。したがって、モデルを適用する範囲をあらかじめ定義することが求められる。

#### 境界つけられたコンテキスト内での分派を認識する
複数のモデルが適用されていることを認識する契機としては、例えばインターフェースを適用できないということが挙げられるが、大抵まずはじめに起こる事象としては言語の混乱である。例としては同じ意味をもつ単語が複数存在したり、一つの単語が人によって別の意味をもったりすることが挙げられる。このような事象が発生した場合には然るべき判断(言語を統一するのかそれとも別々の単語として独立させるのか)を下す必要がある。

### 継続的な統合
他人が作ったモデルを改修するにおいて、モデルの仕様を理解せずに改修を行なったり、すでに実装されている機能を実装しようとしてモデルを複雑にしてしまうことがある。しかし、モデルを理解するためには高い水準でのコミュニケーション能力が求められる。したがって、コミュニケーションを推進して複雑さを減らすのが望ましい。この場合エクストリームプログラミングを行うと有効である。また、エクストリームプログラミングでなくとも以下の取り組みが大切である。  
- 修正内容を頻繁にマージできるプロセスを整える(CI環境 etc...)  
- 自動化されたテストの実行(モデルの分裂にいち早く気づけるため)  
- ユビキタス言語の鍛錬(チームのメンバー間で共通認識を作り上げる)

#### コンテキストマップ
プロジェクトで使用しているモデルをまず認識し、そのモデルがどのコンテキストなのかををはっきりと区別しておくことが望ましい。また、その境界づけられたコンテキストについてもユビキタス言語で表現し、異なるコンテキスト間の変換についてもある程度の取り決めはしておく。  
本書では、配送システムに関して例を挙げている。配送仕様(配送の出発点と到着点、いつ配送されるか etc...) を満たした工程を提供するアプリケーションと、配送経路を選び出す経路選択アプリケーションが別々のコンテキストであった場合に、その2つのアプリケーションで扱うデータを相互に変換するサービスを実装する必要がある。この取り組みがコンテキストマップである。

### 境界づけられたコンテキストの関係

境界づけられたコンテキストの関係にはいくつかのパターンが存在する。このパターンを明確にする理由としては、開発をうまく構成するための目標を与えることと、既存の構成を記述するための語彙を提供することである。

パターンは以下の通り。  
- 共有カーネル  
- 顧客/供給者の開発チーム  
- 公開ホストサービス  
- 腐敗防止層

#### 共有カーネル
異なるコンテキスト間で同一のインフラストラクチャ層を使用しているケースが存在する。その場合、他のコンテキストの実装を担当しているチームへの相談なしにインフラストラクチャ層の修正を行なってはならない。また、修正を行う場合はそのインフラストラクチャ層を使用しているコンテキストのテストを全て実行する。また、インフラストラクチャ層の修正は、コンテキスト内の修正よりも頻度を下げるのが望ましい。

#### 顧客/供給者の開発チーム
あるコンポーネントがあるコンポーネントに対しての入力を与える時、そこには明確な上流と下流の関係が存在する。上流と下流に分けられることによって開発において悪影響となるケースは、下流のチームが変更に対する拒否権を持っていたり、変更の要求に手間がかかり、上流チームの開発が抑制されてしまうケースや、下流チームが上流チームの言いなりになって自分たちではどうすることもできないケースである。  
これを避けるため、上流チームと下流チームの間で要求の内容とスケジュールに関して認識合わせを行ったり、上流が下流への副作用を気にしないために、テストスイートは共同で作成する。

##### 順応者
上流が下流の要望に聞く耳を持たない場合、下流が取るべき行動は3つ存在する。1つ目は上流の機能を使用するのを断念することである。そこまで重要性を感じないソフトウェアにはこの方針が取れる。上流のソフトウェアが有用なものであった場合、下流は独立したモデルを構築するか否かを判断する必要があるが、上流のモデルがぎこちないものあった場合は独立したモデルを構築した方が良い。一方で上流のモデルの品質が悪くないものであった場合は、それに追従するのも一つである。

#### 腐敗防止層
他のコンポーネントの概念を自分のコンポーネントに取り込まないように、自分のコンポーネントの概念に変換する必要がある。その役割を担うのが腐敗防止層である。  
腐敗防止層で有効なデザインパターンが存在する。それは ファサードパターンとアダプターパターンである。他のコンポーネントの複数のインターフェースの窓口をファサードが担当して、そのファサードが提供するインターフェースを用いてアダプターが自身のコンポーネントのサービスクラスで扱うことができるようなインターフェースを提供する。ここで他のコンポーネントのインターフェースが直感的に理解しやすく、扱いやすいものであった場合は、ファサードは必要ない。あくまでファサードは他のコンポーネントのモデルの外観を与えるだけである。  

#### 別々の道
基本的にはコンテキストは他のコンテキストとの結合は避け、繋がりは無くすべきである。しかし、どうしても関連が必要な場合にはこの限りではない。開発者における開発のスコープを明確にし、シンプルな解決策を提案できるようにする。

#### 公開ホストサービス
多くのコンテキストとの繋がりが求められた場合が存在する。この場合、外部の複数のコンテキストが当コンテキストに求める要求は同じだったりする。したがってそれぞれの外部コンテキストに関しては共通のプロトコルを用意して外部からの操作を限定させる。これが公開ホストサービスである。公開ホストサービスは複数のコンポーネントとの関連が存在するときに使用し、単一のコンポーネントの関連しか存在しない場合は変換サービス(コンテキストマップ)を使用する。

#### 公表された言語
既存のモデルが外部に提供する情報は、複雑なものが多い。したがってそのモデル独自がもつ複雑性を回避するために、XMLのような情報交換が容易な媒体(言語)に変換して情報を公開することが必要である。また、そのモデルへデータを挿入する際も、XMLを通してモデルオブジェクトに変換することが必要である。

#### モデルコンテキスト戦略を選択する

##### チームでの意思決定と、より上位層での意思決定
まず決めなけらばならないことは、どういったコンテキストを定義し、他のコンテキストとの関連をどのようなものにするのかということである。これは、少なくともチーム内で認識を合わせておく必要がある。

##### コンテキストに自らの身を置く
常に、自分が携わっているコンテキストや、連携するコンテキストに関して意識して開発を行う。またコンテキストマップについても考えながら開発を行う。

##### 境界を変換する
開発者がどのようにコンテキストの境界を決定するかは、以下の項目に注目して考えてみると良い。より大きな境界づけられたコンテキストとより小さな境界づけられたコンテキストにもメリットは存在する。  

より大きな境界づけられたコンテキスト  
- 統一されたモデルで処理が実現すると、ユーザのタスクフローがスムーズになる  
- 一貫性のある単一のモデルの方が直感的で理解しやすい  
- 複数のモデル間の変換が難しいというリスクを避けることができる  
- 共有された言語により、コミュニケーションが促進される  

より小さな境界づけられたコンテキスト  
- モデルが小さいためにコミュニケーションのオーバーヘッドが減少する  
- CIに関して言えば小さなモデルの方が管理しやすい  
- 小さなモデルであるがために、そのモデルに特化したメンバーを育てやすい  
- 特殊な要求を満たす場合には別の小さなモデルを作るという選択を取ることができて融通がきく  

##### 変更できないものを受け入れる
レガシーシステムなどの明確に境界づけられていないモデルに関しては注意する。

##### 外部システムとの関係
統合が不要な場合は「別々の道」をとる。しかしどうしても統合が必要な場合に関しては、レガシーなモデルが巨大である場合に関しては「順応者」の道をとる。しかし開発を進めていく上で、既存のモデルのインターフェースが貧弱であると感じたら、「腐敗防止層」を用いて拡張を行う。

##### 設計中のシステム
チームが担当するコンテキストのスコープに関して述べておくと、1つのチームにつき1つのコンテキスト、もしくは複数のコンテキストが望ましい。複数のチームが1つのコンテキストに携わると、衝突が発生してスムーズに作業を進めることができないためである。

##### 別のモデルで特殊な要求を満たす
同じモデルにおいて特殊な要求を満たさなければならない時がある。この要求をモデルに組み込むのに抵抗がある場合は、ユビキタス言語は踏襲したものにして別のモデルで実現させる。別々のモデルではあるが共通言語は存在しているので、教諭カーネルを使用できるかもしれない。この場合、抵抗なく特殊な要求を満たすことで変なモデルを正当化してしまうリスクが生じるので気をつける必要がある。

##### デプロイ
複数のコンポーネント間で関連が存在する場合は、デプロイに関しても注意が必要である。一方のバージョンが変更された場合には正常に動作しない可能性が存在するからである。これを回避するためには別々の道を取る必要がある。

##### トレードオフ
モデルを統一させると、シンプルになる反面コミュニケーションコストはモデルの規模に比例して大きくなる。独立させた場合にはコミュニケーションコストは低くなる一方他との連携に動きが制限させる。

##### すでにプロジェクトが進行中の場合
すでにプロジェクトが進行している場合は、変換コードが存在していれば腐敗防止層へリファクタリングし、既存のコンテキストにはユビキタス言語に基づいて名前をつける。

#### 変換
ここではコンテキスト間の関連を変更する方法をパターン別にのべる。

##### コンテキストのマージ：別々の道 -> 共有カーネル
「別々の道」を選択したコンテキスト間のマージに関しては、まずは全てを統合するのは難しいので、一旦共有カーネルを経由してから統合すること。手順としては以下の通り。  

1. それぞれのコンテキストの状況を把握すること。コンテキスト内が統一されたものでなかったらそれぞれのコンテキストを統一することから始めること。  
2. プロセスを準備すること。ここでいうプロセスとは命名規則などの開発を行う上で取るべきプロセスのことを指す。またテストスイートも準備しておくこと。  
3. 共有カーネルに移行するにあたっては、最初からコアドメインから開発を行うのではなく、小さなサブドメインから試験的に移行すること。  
4. サブドメインの開発にあたり、各チームから2~4人を選出して開発に取り組むこと。  
5. 各チームに属していた開発者は両方ともモデリングの作業に参加させること。  
6. 両チームで共有カーネルの開発に取り組むこと。  
7. 不要となった変換は削除すること。  

##### 共有カーネル　-> 継続的な統合
共有カーネルが肥大化してくると、モデル自体を統合したいというニーズが発生するかもしれない。共有カーネルから継続的な統合に移行するためには以下のような手順を取る。  

1. それぞれのチームで統合のプロセスを統一すること。  
2. チーム間でメンバーのローテーションを行うこと。  
3. 各チームでモデルの蒸溜を行うこと。  
4. コアドメインのマージを行う際には、迅速に行うこと。  
5. 共有カーネルへの統合の頻度を1日に一回に増やすこと。  

##### レガシーシステムを段階的に廃止する
割愛

##### 公開ホストサービス　-> 公表された言語
外部に公開してはいるが、独自のプロトコルで公表しているコンテキストを公表された言語に置き換える場合は、以下の手順をとる。  
1. 業界標準の言語が存在すれば、それを採用して変換できるようにすること。  
2. 業界標準の言語が存在しなければ、まずそのモデルのコアドメインを認識すること。  
3. コアドメインから外部への通信用の用語(必ずしもそのモデルのユビキタス言語と一致しない)を選定していくこと。それに加えてXMLのような標準の交換パラダイムを用いること。  
4. 新しい通信用の言語を作業に関わる人に公表すること。  
5. 新しいシステムアーキテクチャが関連する場合はそれも公表すること。  
6. 強調するシステムそれぞれに変換層を構築し、それに切り替えること。  

## 15章　モデルの整合性を維持する
ここではモデルにおいて余計なものを削ぎ落とし、重要な箇所に集中できる方法をのべる。

### コアドメイン
モデルにおいて重要な箇所、すなわちコアドメインは特定するのを容易にしておき、またモデルの規模自体も小さくしておくこと。また優秀な開発者はコアドメインの開発に割り当てること。

### 汎用サブドメイン
コアドメインの中にも、実現したい業務ロジックにおいて必須ではあるのだが本質的でない処理が混在していることがある。このような処理に関しては全て別のモジュールに移行させてコアとなる処理と隔離すること。隔離したら、そのモジュールに関してはコアドメインよりも開発頻度を下げ、可能であれば既製品による解決策や公表されているモデルを採用すること。

### ドメインビジョン声明文
システムの価値をモデルについて詳細に調査をせずとも伝えることができる方法が開発を進める上で必要になることがある。この場合、ドメインビジョン声明文という1ページ程度のそのドメインがどのような役割を果たすのかが記述されたドキュメントが用意されていると便利である。

###　強調されたコア
外部の人がそのモデルに関して理解する時にはドメインビジョン声明文は有効なツールであるが、開発者などが具体的にモデルの各要素がコアモデルかどうかを識別する際には、ドメインビジョン声明文よりも詳細な情報が必要となる。そのような具体的な情報を明らかにする方法が2つ存在する。  

#### 蒸溜ドキュメント
コアドメインと他のドメインとの関連を記述したドキュメントを3~7ページ程度でまとめる。

#### フラグ
コアドメインの要素となるものにフラグをつけておく。

### 凝集されたメカニズム
ソースコードが大規模なものになってくると、ソースコードにおいて「何が(What)」がしめる割合よりも、「どのように(How)」がしめる割合の方が高くなってしまい、結果的にソースコードが直感的には理解しにくくなることがあげられる。この「How」の部分をメカニズムを呼ぶが、ソースコードを理解しやすいものにするために、メカニズムを別個にわけ、フレームワークとして定義し、インターフェースとして扱うことで、メインのコードの「What」の部分を強調させる。また、汎用サブドメインとの違いは、汎用サブドメインはドメインオブジェクトであるのに対し、メカニズムはドメインのロジックを実現するためのものであり、それ自身はドメインを表現しない。

### 隔離されたコア
コアドメインからさらに補助的な役割を担っているものを分離し凝集度を高めつつ、他のコードとの結合度を低くすること。  
1. コアドメインを識別する。  
2. 関連するクラスをそれを関係づけている概念に由来するモジュールへ移動させる。  
3. コードをリファクタリングし、コアドメインの概念を直接表現していないデータと機能を切り離し、別のパッケージに移動させる。  
4. コアのモジュールをリファクタリングし、関係と相互作用を単純にする。  
5. コアドメインが隔離されるまで、1~4を繰り返す。  

#### 隔離されたコアを作るタイミング
システムにおいて巨大なコンテキストが存在し、モデルの本質的な部分が補助的な機能によって理解しにくくなった時に隔離されたコアを作成する。

### 抽象化されたコア
複数のモジュール間で様々な相互作用や参照が生じるシステムは複雑になりやすい。この場合は各モジュールにおける主要な概念をインターフェースや抽象クラスで定義しまとめて一つのモジュールとして定義する。そしてそのモジュールで相互作用や関連を表現する。

## 大規模な構造
ここでは大規模なシステムの概要を把握するために役割や関連性についてのパターンを紹介する。

### 進化する秩序
しばしば大規模なシステムの内部が無秩序であるがために構造が複雑化すると考えられているが、秩序の有無ではなく、厳格すぎる秩序が存在するために融通が効かない構造となり、結果的に複雑な構造が作られる。したがって、構造自体は変更することを容認し、構造に対して厳格な制約を課してはならない。

### システムのメタファ
システムの理解や構築において、メタファを使用するのは有効な手法である。メタファをユビキタス言語に採用することで、コミュケーションを円滑に行うことができることがある。しかし、メタファとは不正確なものであるために、ユビキタス言語に採用するときは慎重に検討すること。また、メタファが有効でなくなったと感じたときは、それを捨て去る勇気を持つこと。

### 責務のレイヤ(あとで確認)
レイヤードアーキテクチャにより、各オブジェクトはどこかのレイヤに位置し、その役割を明確にしているが、大規模な構造に関しても階層構造をとることは有効である。上位の層は下位の層に依存し、下位の層は独立した構造をとること。

### 知識レベル
アプリケーションにはユーザに様々なオプションを提供するものがあるが、これはアプリケーションが汎用的になる反面ユーザの操作によってアプリケーションの振る舞いを変更せねばならず、処理が複雑になり最悪意図しない挙動をとる結果となる。これを避けるために、知識レベルというオブジェクトを定義する。知識レベルとは、基本となるモデルがあったとして、そのモデルの構造と振る舞いをリフレクションなどを使用して制約するものである。

### 着脱可能のコンポーネントフレームワーク
開発を進めていくと、ドメインの中で中核を担うハブとなるオブジェクトが定義されることがある。そのオブジェクトは、他のコンポーネントとの通信のためのプロトコルやインターフェースを実装している。この場合、使用しているインターフェースの置換を容易に行うことができるフレームワークを定義すること。しかし、このフレームワークは実装が難しい、アプリケーションの設計がそのフレームワークに縛られるなどの欠点が存在する。

### 構造による制約をどの程度厳しくすべきか？
今まで話してきたパターンはどれも開発を容易にするためのパターンなので、それに外れた使い方をしてはならない。

### ふさわしい構造へのリファクタリング
- ミニマリズム  
- コミュニケーションと自己規律  
- 再構成によってしなやかな設計がもたらされる  
- 蒸留によって負担が軽減される

## 戦略をまとめ上げる

# 参考文献
https://www.ogis-ri.co.jp/otc/hiroba/technical/DDDEssence/chap3.html