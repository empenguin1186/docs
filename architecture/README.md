
# ソフトウェアアーキテクチャの責務

## ソフトウェアアーキテクチャの構成要素
- システムの構造
  - アーキテクチャスタイルのこと(マイクロサービス、レイヤード etc...)
- アーキテクチャ特性
  - システムの機能とは直接は関係しないが、システムの成功基準を定義する上で考慮しなければならないこと。非機能要件みたいなもの？(可用性、スケーラビリティ、パフォーマンス etc...)
- アーキテクチャ決定
  - どのようにシステムを構築するのかをコードレベルで考えること(レイヤードアーキテクチャで構築する場合はビジネス層とサービス層のみデータベースにアクセスでき、プレゼンテーション層はアクセスを行わないようにする)。そして決定した方針をメンバーに順守させること。
- 設計指針
  - 開発におけるガイドラインを提供すること。基本的に決定した方針を順守させるアーキテクチャ設計とは異なり、より望ましいアプローチを提供するといったような緩さのもの(REST or Grpc)。

## アーキテクチャに期待すること
- アーキテクチャ決定を下す
  - 特定の技術を使用することを指示するのではく、構築するシステムに対して望ましい特性を持つ技術を使用することを指示する(React を使用するように指示するのではなく、リアクティブベースのフレームワークを使用することを指示する)。
- アーキテクチャを継続的に分析する
  - すでにリリースされているシステムに対して、適用されているアーキテクチャが最適かどうかを継続的に分析することが求められる。
- 最新のトレンドを把握し続ける
  - 自明なので省略
- 決定の順守を徹底する
  - レイヤードアーキテクチャを採用しているのにもかかわらず、データベースへのアクセスをプレゼンテーション層に実装することのないようにといったような、指針の順守を徹底させる
- 様々なものに触れ、経験している
  - アーキテクトにおける引き出しを増やしておく。この点に関しては技術的な深さよりも幅を優先するように知識を習得するのが望ましい。
- 事業ドメインの知識を持っている
  - 対象となるサービスの知識を理解していないと最適なアーキテクチャを検討することは難しい。金融システムのアーキテクチャを検討するにあたり、金融用語を知っていないとどのようにシステムを構築すればいいのか見当もつかないし、ステークホルダーとのこのコミュニケーションもうまくいかない可能性がある。
- 対人スキルを持ち合わせている
  - チームへの指導や設計指針の伝達など、アーキテクチャには対人スキルを求められる場面が多い。
- 政治を理解し、舵取りをする
  - 考案したアーキテクチャで開発を進めるためにプロジェクトマネージャ、ビジネスサイド、または開発者を納得させねばならない。

## アーキテクチャと交わるもの

### エンジニアリングプラクティス
- 問題を解決しようとしている領域に適したシステムアーキテクチャがあるのと同様に、特定のシステムアーキテクチャに適したエンジニアリングプラクティス(開発プロセスのことを指す。具体的には CI/CD の導入など)も存在する。したがって開発者は採用するアーキテクチャに適したエンジニアリングプラクティスを実施するのが望ましい。例えばマイクロサービスアーキテクチャはここのシステムの規模が小さいので開発のイテレーションを重ねていくことになるためCI/CDの導入は必須である。
- また運用していく上でシステムのアーキテクチャは開発を重ねていくたびに変化していくことになるので、定期的にシステムのアーキテクチャ特性が十分かどうかを確認する必要がある。確認するためにはアーキテクチャ適応度関数という考え方を取り入れることが望ましい。アーキテクチャ適応度関数とはそのシステムのアーキテクチャ特性を定量化したものである。例えば、とあるシステムでページの読み込み時間をなるべく短くすることに関心がある場合、その読み込み時間を計測するようなテストなりメトリクスを用意して常にモニタリングできるような体制を整えておくといった取り組みが該当する。

# 1部 アーキテクトに必要な考え方
## アーキテクチャ思考とは
- アーキテクチャ思考とは以下の5つ要素で構成される

### 開発側との相互的な連携を行う
- 従来は問題領域に対応したシステムのアーキテクチャをアーキテクトが考え、実際のシステムの構築は開発側に委ねるような体制が一般的であったが、昨今ではそういったアーキテクトと開発側の壁は取り払い共同してシステムの開発に取り組むことが求められる。

### 技術的な深さではなく幅を広げることを意識する
- 問題領域に適したアーキテクチャを考案する場合には、多くの選択肢を提示できるアーキテクトである方が望ましい。したがって特定の技術に特化した知識を身につけるよりも様々な知識を知っている方がアーキテクトとしては重宝される。

### トレードオフを分析する
- 問題領域における特有の事情と採用する技術を考慮し、検討しているアーキテクチャのメリット・デメリットを考えて各アーキテクチャを評価することが必要。

### ビジネスドライバーを理解する
- ビジネスを成功させるために考慮すべき要素をアーキテクチャ特性に変換するスキルや、それを定期的に評価する方法を検討する必要がある。

### アーキテクティングとコーディングのバランスをとる
- 開発側との共同が必要となってくるために、アーキテクトにも現場感覚を持つことが重要となってくる。したがって概念実証や些細な改修や開発生産性向上のためのツールの導入、コードレビューなどを行うことで現場感を養うことが重要。


# 2部 アーキテクチャスタイル

## 基礎
### 分散型のデメリット
- パフォーマンス、スケーラビリティ、可用性は分散型の方が優れている
- ネットワークの信頼性や安全性に比例してサービスのクオリティが変化してしまうのが分散型のデメリット
- レイテンシに関しては分散型よりもローカル通信で完結するモノリシック型の方が小さくなる傾向がある
- 使用する帯域幅はモノリシックの方が小さい
- ログが分散しているため原因の特定が難しい
- トランザクションの管理が難しいのでデータの整合性や完全性を担保することが難しい

## 各種アーキテクチャ

### レイヤードアーキテクチャ
- 小規模でシンプルなアプリケーションを開発する際に適しているアーキテクチャ。ただだんだんシステムが複雑化してくると他のアーキテクチャに乗り換える必要がでてくる。
- モノリシックなアプリケーションであることやモジュール性の欠如が原因で弾力性とスケーラビリティは低い。
- パフォーマンスも開発側が工夫しなければ決して優れているとは言えない。
- モノリシックなアプリケーションから耐障害性も高いとは言えない。システムの一部でメモリ不足が発生した場合にシステム全体がダウンする。

### サービスベースアーキテクチャ
- 複数のユーザインターフェース、複数のコンポーネント(基本的には各コンポーネントはレイヤードアーキテクチャで実装されている)、単一のデータベースが基本形となる。ただしデータベースに関してもドメインごとに分割する方法も存在する。
- マイクロサービスアーキテクチャと異なる点としては、ドメインサービスの粒度がマイクロサービスアーキテクチャと比べて粗くなる点と他のドメインサービスの呼び出しにおいては外部通信を用いるのではなく、内部でのクラスの呼び出し、もしくは内部間通信でもって実行される点である。これによるメリットとしてはデータの整合性を保てる点が挙げられる。マイクロサービスアーキテクチャでは基本的にはBASEトランザクションであることに比べ、サービスベースアーキテクチャは各ドメインサービスごとにトランザクションを管理するためACID特性を保つことができる傾向がある。また基本的にサービス間通信はローカルになるので帯域幅を節約できるのもメリットである。
- また各ドメインサービスごとにデプロイメントユニットが分割されている場合にはスケーリングを柔軟に行うことができる点もメリットとして挙げられる。
- 逆にマイクロサービスアーキテクチャよりも劣っている点としてはテストの実行難易度や改修の難易度はサービスベースアーキテクチャの方が高くなる傾向がある。これはサービスの粒度がマイクロサービスアーキテクチャよりも粗いために、些細な改修でも影響する範囲が大きくなってしまいデプロイまでの時間がかかりアジリティが損なわれてしまう懸念がある。

### イベント駆動アーキテクチャ
ほとんどのシステムがUIの操作から実行されるリクエストを処理するリクエストベースのアーキテクチャで構築されていることに対し、イベント駆動アーキテクチャとは何かしらのイベントが発行された場合に、イベントを処理する複数のイベントプロセッサーが処理を行ってサービスにおけるとある機能を実現する。例としてはオークションにおける入札機能が挙げられる。個々の入札リクエストを処理するのではなく、希望価格が提示された場合に、現状の入札状況を考慮して最高額を提示した入札者を決定するような処理はイベント駆動で処理されることが望ましい。

#### イベント駆動アーキテクチャにおける2つのトポロジー

##### ブローカー
ブローカー方式のイベント駆動アーキテクチャとはそれぞれイベントを処理するイベントプロセッサーがメッセージキューなどのブローカーを介して相互に連携する方式のことを指す。オンラインのショッピングシステムを例に取った場合、注文を行うことで一番最初のイベントが発行される。その後注文イベントを処理するプロセッサーがメッセージキューに注文イベントをキューイングする。その後、注文を受け付けたことをメールで送信する処理を実行する通知イベントプロセッサーや、注文内容に基づいて決済を行う決済イベントプロセッサーが注文イベントをメッセージキューからサブスクライブしてそれぞれの処理を実行する。
ブローカー方式のメリットとしてはそれぞれのイベントプロセッサーはそれぞれ独立して動いているため、システムとしては疎結合なつくりとなりパフォーマンスや応答性、スケーラビリティがが優れている点が挙げられる。一方デメリットとしてはそれぞれのイベントプロセッサーが独立して動いているため、最終的に処理が成功したかどうかは知る由がないことが挙げられる。またそれぞれがメッセージキューを介してのみイベントを受け取るために、イベントを送信したプロセッサーが正常に動いているかどうかもわからないので、エラー処理が難しくなる点もデメリットの一つである。

##### メディエーター
メディエーター方式はブローカー方式のデメリットを解消するような構成となっている。開始イベントをメッセージキューに送信するところは同じだが、メディエーター方式ではその開始イベントをメディエーターと呼ばれる全体の処理を制御するプロセスが受け取る。イベントを受け取ったメディエーターは処理の完了に必要なイベントプロセッサーに対して、メッセージキューを介して全体の処理を実行していく(メッセージの送信は機能によって同期/非同期に分かれる)。イベントメディエーターは単純な処理に関しては自分で処理するなりイベントプロセッサーに渡すなりするが、処理が難しい場合は他のイベントメディエーターにイベントを送信するといったことも行う。
全体の処理を制御するメディエーターを置くことで、ブローカー方式に比べエラー処理が容易になることがメディエーター方式のメリットである。ただし制御を行う分パフォーマンス面に関してはブローカー方式には劣る。またメディエーターと各種イベントプロセッサーは結合しているために、スケーリングの単位がブローカー方式に比べ大きくなってしまうこともデメリットとして挙げられる。

#### エラー処理への対処
イベント駆動アーキテクチャによる非同期処理ではエラー処理をどのように行うかが課題となっている。これに関してはワークフロー移譲を使用することで解決することができる。ワークフロー制御とは、エラーが発生した際にそのことをイベントとしてメッセージキューに送信し、そのエラーイベントを処理するワークフロープロセッサーを別途立てることでエラー処理を行うことである。ワークフロープロセッサーはエラー内容を解析し、正常な状態のイベントに整形してから再びエラーイベントを送信したプロセッサーがサブスクライブしているメッセージキューにそのイベントを送信することで処理を続行する。

#### データロストへの対処
イベント駆動アーキテクチャによる非同期通信ではデータのロストに対しても慎重に扱わなければならない。ここで下記のような構成を考える。
```
<イベントプロセッサーA> -1- <メッセージキュー> -2- <イベントプロセッサーB> -3- <データベース> 
```
ここでデータロストが発生する箇所は以下。
1. A と メッセージキュー間。メッセージキューがクラッシュしている場合や、メッセージキューがイベントを受け取り切る前にAがクラッシュした場合など。
2. メッセージキューとB間。メッセージキューからイベントを処理するまでにBがクラッシュした場合など。
3. Bとデータベース間。データベースへの永続化に失敗する。
1. に関しては同期通信を行うことで解決することが可能。またメッセージキューはイベントを受け取ったらインメモリだけでなくディスクにデータを格納して永続化を行うので、クラッシュした場合もデータのロストは発生しない。2. に関してはクライアント応答モードというモードを使用することで解決できる。クライアント応答モードを使用することで、受け取られたイベントであってもそのままキューに残すことができ、Bがクラッシュした場合でもデータのロストが発生しない。3.に関してはACIDトランザクションを活用することで対応が可能。また、データの永続化が成功した場合に永続化されたキューからイベントを削除するようなLPSという機能も存在する

#### イベント駆動で同期処理を実現したい場合
イベント駆動アーキテクチャは基本的にはリクエスト駆動ではないため、処理としては非同期になるが、同期処理で実装したいケースも場合によっては考えられる。これは相関IDを使用することで実現可能である。
まずイベントプロデューサーがイベントを発行する。この場合IDに一意なものを付与してリクエスト専用のキューに送信する。その後プロデューサーはそのイベントが処理されるまで全体の処理をブロッキングする。この際IDとはまた別の相関IDというものが先ほど設定したIDと同じ値であるイベントがリプライ専用のキューに格納された場合までブロッキングする。イベントコンシューマー側はイベントを受けっとったら処理を実行し、最後に相関IDにIDの値を設定してリプライキューに処理ずみイベントを送信する。

#### 総評
イベント駆動アーキテクチャはパフォーマンス、スケーラビリティ、耐障害性については比較的に高い傾向がある。高パフォーマンスは非同期通信と高い並列性によって実現される。また高スケーラビリティは高度に分割されたプロセッサーによって構成されるので、ロードバランシングが容易となっていることから実現される。また高耐障害性については非同期処理によって後続のプロセッサーが機能しない場合でもクライアントにはレスポンスを返すことができる点によって実現される。その一方で基本的に非同期処理がメインなので単純性とテスト容易性は低い傾向がある。

### マイクロサービスアーキテクチャ
- DDD でいうところの「境界づけられたコンテキスト」に基づいてドメインサービスを構築し、それらを単体のデプロイメントユニットとしてデプロイする。各種ドメインサービスは相互に連携することによってあらゆる機能を実現する。
- 基本的にサービス間の連携には外部通信を行うことになるので通信の信頼性や耐障害性、パフォーマンスなどが問題に挙げられることがある。信頼性や耐障害性に関してはサービスディスカバリの使用やスケーリングによってある程度は解決することができる。パフォーマンスに関しては外部通信を行うたびにセキュリティチェックといったオーバーヘッドがかかるのが原因として挙げられるが、データのキャッシュやレプリケーションを賢く利用することで外部通信を極力抑えることができる。


## 適切なアーキテクチャの選定ができるためには
アーキテクチャの選定に関しては以下の事項を考慮する。
- ドメイン
  - 主要なドメインの側面に関してはある一定の理解をしておく必要がある。
- アーキテクチャ特性
  - そのシステムが満たすべきアーキテクチャ特性を明らかにしておく必要がある。
- データアーキテクチャ
  - 連携するデータベースがどれくらいあるのか、それは新規で構築するのか既存のものを使用するのか
- 組織的な要因
  - 利用を検討しているクラウドベンダーのコストがどれくらいか、また企業がM&Aを計画している場合にはシステムがオープンソースで設計されているかどうか
- 開発チームの開発プロセスが検討しているアーキテクチャにマッチしているか。例えばアジャイル開発に経験がないチームがアジャイル開発に依存したアーキテクチャを採用するのはリスクが高い。

上記を踏まえ、アーキテクチャを検討する際の観点は以下。
- モノリスか分散か
  - シンプルな設計を重視するか、スケールやパフォーマンスの柔軟性を重視するか
- データをどこに置くべきか
  - データ分割の仕方
- サービス間通信は同期か非同期か
  - 非同期通信はパフォーマンスやスケーラビリティの面ではその恩恵を受けることができるが、データの整合性やデバッグ容易性が下がり運用面に課題がある。一方同期通信はスケーラビリティと信頼性は非同期通信には劣るが非同期通信で考慮しなければならないデメリットは考えなくて良い。したがって基本的には同期通信の使用が望ましい。


# チェックリスト

## イントロダクション

- ソフトウェアアーキテクチャを定義する4つの側面は何か
  - 構造
    - アーキテクチャスタイルの種類(マイクロサービス or レイヤード、マイクロカーネルなど)
  - アーキクテチャ特性
    - 非機能要件
  - アーキテクチャ決定
    - 開発チームにおけるコーディングの指針(データアクセスを行うことができるのはサービスとビジネス層に限定する etc...)
  - 設計指針
    - 開発のガイドライン的な立ち位置。遵守することはMUSTではないが、迷った時に意思決定の材料になるもの。
- アーキテクチャ決定と設計指針の違いを説明せよ
  - アーキテクチャ決定は原則的に必ず従うものだが、設計指針はガイドライン的な立ち位置であり遵守するものではない。
- ソフトウェアアーキテクトへの8つの期待を挙げよ
  - アーキテクチャ決定を下す
  - アーキテクチャを継続的に分析する
  - 最新のトレンドを把握し続ける
  - 決定の遵守を徹底する
  - さまざまなものに触れ、経験している
  - 事業のドメインの知識を持っている
  - 対人スキルを持っている
  - 政治を理解し、舵取りをする
- ソフトウェアアーキテクチャの第一法則とは何か
  - ソフトウェアアーキテクチャはトレードオフが全てだ

## アーキテクチャ思考
- アーキテクチャと開発の従来型のアプローチを説明し、そのアプローチがもはや機能しない理由
  - 従来型のアプローチではアーキテクトと開発間に隔たりがあり意思の疎通が難しい体制となっている。アーキテクトを機能させるにはアーキテクトと開発の双方向のコミュニケーションが必須である。
- 知識の三角形における知識の3つのレベルを列挙し、それぞれの例を挙げよ
  - わかっていること、わかっていないとわかっていること、わかっていないとわかっていないこと。
- アーキテクトにとって技術的な深さよりも技術的な幅に焦点を当てることが重要なのはなぜか
  - アーキテクトとしてより多くの選択肢を検討できることが望ましいから。
- アーキテクトとして技術的な深さを維持し、現場感を持ち続けるための工夫にはどのようなものがあるか
  - 概念実証やコードレビュー、生産性向上のための簡単なツールの開発などを行い、コーディングに費やす時間を増やす。

## モジュール性
- コナーセンスとは
- 静的なコナーセンスと動的なコナーセンスの違いは
- 型のコナーセンスは何を意味するか。それは静的なコナーセンスと動的なコナーセンスのどちらかに含まれるか
- コナーセンスの最も強い形は何か
- コナーセンスの最も弱い形は何か
- コードベースで望ましいのは、静的なコナーセンスと動的なコナーセンスのどちらか

## アーキテクチャ特性
- アーキテクチャ特性とみなされる基準を3つ挙げよ
  - ドメインによらない、設計に関する考慮事項を明らかにするもの
  - 設計の構造的な側面に影響を与えるもの
  - アプリケーションの成功に不可欠か重要なもの
- 明示的な特性と暗黙的な特性との違いは何か。それぞれの例を挙げよ
  - 明示的な特性とは既にそれが必要だと明らかになっている特性のことを指す。
  - 暗黙的な特性とは、要件にはあらわれてこないものの、そのシステムに必須である特性のことを指す。例えば証券取引システムを構築する場合、取引の処理は低レイテンシーでなければならないのは設計時に明文化されておらずとも考慮しなければならない特性であると考えられる。
- 運用特性の例を挙げよ
  - 可用性、継続性(障害復旧能力)、パフォーマンス、信頼性/安全性
- 構造特性の例を挙げよ
  - 構造特性はコードの構造に目を向けた特性のことを指す。
  - 構成容易性(アプリケーションの設定が容易にできるかどうか)
  - 拡張性(新しい機能をプラグインで追加する場合の追加容易性)
  - インストール容易性
  - 活用性/再利用性
  - ローカライゼーション
  - メンテナンス容易性
  - アップグレード容易性
- 横断的特性の例を挙げよ
  - アクセシビリティ
  - 長期保存性
  - 認証
  - 認可
  - 合法性
  - プライバシー
  - セキュリティ
  - サポート容易性
  - ユーザビリティ
- 可用性とパフォーマンス、どちらのアーキテクチャ特性を目指すことがより重要か

## アーキテクチャ特性を明らかにする
- アーキテクチャがサポートすべき特性の数を制限することが良い習慣である理由を述べよ
  - サポートする特性が増えると設計段階でシステムの複雑度が高くなるため。
- ほとんどのアーキテえクチャ特性がビジネス要件とユーザーストーリーに由来するというのは正しいか
  - 正しい
- ビジネスのステークホルダーが、市場投入までの時間最も重要なビジネス上の関心ごとだと述べた場合、アーキテクチャはどのアーキテクチャ特性をサポートする必要があるか
  - テスト容易性、デプロイ容易性、アジリティ
- スケーラビリティと弾力性の違いを述べよ
  - スケーラビリティは定常的に使用しているユーザの数から導き出される。一方弾力性とは瞬間的な負荷に耐えられるような構成になっているかどうかの指標である。
- 顧客基盤を大幅に増やすために大規模な買収を行う方針となった。この場合どのようなアーキテクチャ特性を心配する必要があるか
  - 相互運用性、スケーラビリティ、適応性、拡張性

## アーキテクチャ特性の計測と統制
- 循環的複雑度がアーキテクチャを分析する上で重要な指標なのは何故か
  - コードの循環的複雑度が高いとモジュール性、テスト容易性、デプロイ容易性などさまざまな特性に悪影響を与えるため。
- アーキテクチャ適応度関数とは何か。
  - あるアーキテクチャ特性を客観的に評価するために定義される関数。関数自体は作りたいシステムごとに異なる。
- アーキテクチャのスケーラビリティを計測するためのアーキテクチャ適応度関数の例を示せ
  - リクエスト量に応じてキャパシティを増やせるような仕組みが整っているかどうか
- アーキテクトや開発者が適応度関数を作成できるようにするための、アーキテクチャ特性の最も重要な基準は何か
  - モジュール性。各コンポーネントが相互に参照を行っているとあるコンポーネントを使用したい場合は参照している別のコンポーネントも依存関係に加えることになるのでモジュール性が失われ、アーキテクチャは巨大な泥団子アンチパターンに向かうことになる。そうなるとテスト容易性、デプロイ容易性などのさまざまなアーキテクチャ特性に悪影響を及ぼすことになる。

## アーキテクチャ特性のスコープ
- アーキテクチャ量子とは何か。なぜアーキテクチャ量子はアーキテクチャにとって重要なのか
  - 独立してデプロイ可能な、高度な機能的凝集性を持つ、独立してデプロイ可能なコンポーネント。アーキテクチャ量子はアーキテクチャにとって重要なのかはアーキテクチャ量子ごとにアーキテクチャ特性が異なるため。
- 1つのユーザーインターフェースと4つの独立してデプロイされたサービスがあり、各サービスが独立したデータベースを持つシステムがあった場合、アーキテクチャ量子はいくつになるか
  - ユーザインターフェースが各サービスと結合されているので1つ？
- 静的な参照データを管理する管理部門と、発注を管理する顧客対応部門を持つシステムがあるとする。このシステムのアーキテクチャ量子はいくつにすべきか。また、その理由は何か。
  - 2つ？

## コンポーネントベース思考
- アプリケーションやサービスの中で、コンポーネントは通常どのように表現されるか
  - ライブラリ
- 技術による分割とドメインによる分割の違いは何か
  - 技術による分割とは、レイヤードアーキテクチャにおけるプレゼンテーション層、ビジネスロジック層、データ永続化層への分割するような、技術的な関心によって分割することである。一方ドメインによる分割とはビジネスロジックに基づいた分割のことを指す。どちらがいいかはケースによる。
- ドメインによる分割の利点は何か
  - とあるビジネスの関心事毎にコンポーネントが分割されている点。一方技術的な分割では各レイヤーごとにビジネスの関心事に関連した実装を行わなければならない。
- ドメインによる分割よりも技術による分割が望ましいケースは何か
  - 技術による分割はコードをプレゼンテーション、ビジネス、永続化層に分け各層の依存関係を明確にするので、アプリケーションとしては疎結合な構造にすることができる。各層の役割が明確になっているのでコードが整理され理解しやすくなる。