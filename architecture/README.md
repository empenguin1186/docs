
# ソフトウェアアーキテクチャの責務

## ソフトウェアアーキテクチャの構成要素
- システムの構造
  - アーキテクチャスタイルのこと(マイクロサービス、レイヤード etc...)
- アーキテクチャ特性
  - システムの機能とは直接は関係しないが、システムの成功基準を定義する上で考慮しなければならないこと。非機能要件みたいなもの？(可用性、スケーラビリティ、パフォーマンス etc...)
- アーキテクチャ決定
  - どのようにシステムを構築するのかをコードレベルで考えること(レイヤードアーキテクチャで構築する場合はビジネス層とサービス層のみデータベースにアクセスでき、プレゼンテーション層はアクセスを行わないようにする)。そして決定した方針をメンバーに順守させること。
- 設計指針
  - 開発におけるガイドラインを提供すること。基本的に決定した方針を順守させるアーキテクチャ設計とは異なり、より望ましいアプローチを提供するといったような緩さのもの(REST or Grpc)。

## アーキテクチャに期待すること
- アーキテクチャ決定を下す
  - 特定の技術を使用することを指示するのではく、構築するシステムに対して望ましい特性を持つ技術を使用することを指示する(React を使用するように指示するのではなく、リアクティブベースのフレームワークを使用することを指示する)。
- アーキテクチャを継続的に分析する
  - すでにリリースされているシステムに対して、適用されているアーキテクチャが最適かどうかを継続的に分析することが求められる。
- 最新のトレンドを把握し続ける
  - 自明なので省略
- 決定の順守を徹底する
  - レイヤードアーキテクチャを採用しているのにもかかわらず、データベースへのアクセスをプレゼンテーション層に実装することのないようにといったような、指針の順守を徹底させる
- 様々なものに触れ、経験している
  - アーキテクトにおける引き出しを増やしておく。この点に関しては技術的な深さよりも幅を優先するように知識を習得するのが望ましい。
- 事業ドメインの知識を持っている
  - 対象となるサービスの知識を理解していないと最適なアーキテクチャを検討することは難しい。金融システムのアーキテクチャを検討するにあたり、金融用語を知っていないとどのようにシステムを構築すればいいのか見当もつかないし、ステークホルダーとのこのコミュニケーションもうまくいかない可能性がある。
- 対人スキルを持ち合わせている
  - チームへの指導や設計指針の伝達など、アーキテクチャには対人スキルを求められる場面が多い。
- 政治を理解し、舵取りをする
  - 考案したアーキテクチャで開発を進めるためにプロジェクトマネージャ、ビジネスサイド、または開発者を納得させねばならない。

## アーキテクチャと交わるもの

### エンジニアリングプラクティス
- 問題を解決しようとしている領域に適したシステムアーキテクチャがあるのと同様に、特定のシステムアーキテクチャに適したエンジニアリングプラクティス(開発プロセスのことを指す。具体的には CI/CD の導入など)も存在する。したがって開発者は採用するアーキテクチャに適したエンジニアリングプラクティスを実施するのが望ましい。例えばマイクロサービスアーキテクチャはここのシステムの規模が小さいので開発のイテレーションを重ねていくことになるためCI/CDの導入は必須である。
- また運用していく上でシステムのアーキテクチャは開発を重ねていくたびに変化していくことになるので、定期的にシステムのアーキテクチャ特性が十分かどうかを確認する必要がある。確認するためにはアーキテクチャ適応度関数という考え方を取り入れることが望ましい。アーキテクチャ適応度関数とはそのシステムのアーキテクチャ特性を定量化したものである。例えば、とあるシステムでページの読み込み時間をなるべく短くすることに関心がある場合、その読み込み時間を計測するようなテストなりメトリクスを用意して常にモニタリングできるような体制を整えておくといった取り組みが該当する。

# 1部 アーキテクトに必要な考え方
## アーキテクチャ思考とは
- アーキテクチャ思考とは以下の5つ要素で構成される

### 開発側との相互的な連携を行う
- 従来は問題領域に対応したシステムのアーキテクチャをアーキテクトが考え、実際のシステムの構築は開発側に委ねるような体制が一般的であったが、昨今ではそういったアーキテクトと開発側の壁は取り払い共同してシステムの開発に取り組むことが求められる。

### 技術的な深さではなく幅を広げることを意識する
- 問題領域に適したアーキテクチャを考案する場合には、多くの選択肢を提示できるアーキテクトである方が望ましい。したがって特定の技術に特化した知識を身につけるよりも様々な知識を知っている方がアーキテクトとしては重宝される。

### トレードオフを分析する
- 問題領域における特有の事情と採用する技術を考慮し、検討しているアーキテクチャのメリット・デメリットを考えて各アーキテクチャを評価することが必要。

### ビジネスドライバーを理解する
- ビジネスを成功させるために考慮すべき要素をアーキテクチャ特性に変換するスキルや、それを定期的に評価する方法を検討する必要がある。

### アーキテクティングとコーディングのバランスをとる
- 開発側との共同が必要となってくるために、アーキテクトにも現場感覚を持つことが重要となってくる。したがって概念実証や些細な改修や開発生産性向上のためのツールの導入、コードレビューなどを行うことで現場感を養うことが重要。


# 2部 アーキテクチャスタイル

## 基礎
### 分散型のデメリット
- パフォーマンス、スケーラビリティ、可用性は分散型の方が優れている
- ネットワークの信頼性や安全性に比例してサービスのクオリティが変化してしまうのが分散型のデメリット
- レイテンシに関しては分散型よりもローカル通信で完結するモノリシック型の方が小さくなる傾向がある
- 使用する帯域幅はモノリシックの方が小さい
- ログが分散しているため原因の特定が難しい
- トランザクションの管理が難しいのでデータの整合性や完全性を担保することが難しい

## 各種アーキテクチャ

### レイヤードアーキテクチャ
- 小規模でシンプルなアプリケーションを開発する際に適しているアーキテクチャ。ただだんだんシステムが複雑化してくると他のアーキテクチャに乗り換える必要がでてくる。
- モノリシックなアプリケーションであることやモジュール性の欠如が原因で弾力性とスケーラビリティは低い。
- パフォーマンスも開発側が工夫しなければ決して優れているとは言えない。
- モノリシックなアプリケーションから耐障害性も高いとは言えない。システムの一部でメモリ不足が発生した場合にシステム全体がダウンする。

### サービスベースアーキテクチャ
- 複数のユーザインターフェース、複数のコンポーネント(基本的には各コンポーネントはレイヤードアーキテクチャで実装されている)、単一のデータベースが基本形となる。ただしデータベースに関してもドメインごとに分割する方法も存在する。
- マイクロサービスアーキテクチャと異なる点としては、ドメインサービスの粒度がマイクロサービスアーキテクチャと比べて粗くなる点と他のドメインサービスの呼び出しにおいては外部通信を用いるのではなく、内部でのクラスの呼び出し、もしくは内部間通信でもって実行される点である。これによるメリットとしてはデータの整合性を保てる点が挙げられる。マイクロサービスアーキテクチャでは基本的にはBASEトランザクションであることに比べ、サービスベースアーキテクチャは各ドメインサービスごとにトランザクションを管理するためACID特性を保つことができる傾向がある。また基本的にサービス間通信はローカルになるので帯域幅を節約できるのもメリットである。
- また各ドメインサービスごとにデプロイメントユニットが分割されている場合にはスケーリングを柔軟に行うことができる点もメリットとして挙げられる。
- 逆にマイクロサービスアーキテクチャよりも劣っている点としてはテストの実行難易度や改修の難易度はサービスベースアーキテクチャの方が高くなる傾向がある。これはサービスの粒度がマイクロサービスアーキテクチャよりも粗いために、些細な改修でも影響する範囲が大きくなってしまいデプロイまでの時間がかかりアジリティが損なわれてしまう懸念がある。

### イベント駆動アーキテクチャ
ほとんどのシステムがUIの操作から実行されるリクエストを処理するリクエストベースのアーキテクチャで構築されていることに対し、イベント駆動アーキテクチャとは何かしらのイベントが発行された場合に、イベントを処理する複数のイベントプロセッサーが処理を行ってサービスにおけるとある機能を実現する。例としてはオークションにおける入札機能が挙げられる。個々の入札リクエストを処理するのではなく、希望価格が提示された場合に、現状の入札状況を考慮して最高額を提示した入札者を決定するような処理はイベント駆動で処理されることが望ましい。

#### イベント駆動アーキテクチャにおける2つのトポロジー

##### ブローカー
ブローカー方式のイベント駆動アーキテクチャとはそれぞれイベントを処理するイベントプロセッサーがメッセージキューなどのブローカーを介して相互に連携する方式のことを指す。オンラインのショッピングシステムを例に取った場合、注文を行うことで一番最初のイベントが発行される。その後注文イベントを処理するプロセッサーがメッセージキューに注文イベントをキューイングする。その後、注文を受け付けたことをメールで送信する処理を実行する通知イベントプロセッサーや、注文内容に基づいて決済を行う決済イベントプロセッサーが注文イベントをメッセージキューからサブスクライブしてそれぞれの処理を実行する。
ブローカー方式のメリットとしてはそれぞれのイベントプロセッサーはそれぞれ独立して動いているため、システムとしては疎結合なつくりとなりパフォーマンスや応答性、スケーラビリティがが優れている点が挙げられる。一方デメリットとしてはそれぞれのイベントプロセッサーが独立して動いているため、最終的に処理が成功したかどうかは知る由がないことが挙げられる。またそれぞれがメッセージキューを介してのみイベントを受け取るために、イベントを送信したプロセッサーが正常に動いているかどうかもわからないので、エラー処理が難しくなる点もデメリットの一つである。

##### メディエーター
メディエーター方式はブローカー方式のデメリットを解消するような構成となっている。開始イベントをメッセージキューに送信するところは同じだが、メディエーター方式ではその開始イベントをメディエーターと呼ばれる全体の処理を制御するプロセスが受け取る。イベントを受け取ったメディエーターは処理の完了に必要なイベントプロセッサーに対して、メッセージキューを介して全体の処理を実行していく(メッセージの送信は機能によって同期/非同期に分かれる)。イベントメディエーターは単純な処理に関しては自分で処理するなりイベントプロセッサーに渡すなりするが、処理が難しい場合は他のイベントメディエーターにイベントを送信するといったことも行う。
全体の処理を制御するメディエーターを置くことで、ブローカー方式に比べエラー処理が容易になることがメディエーター方式のメリットである。ただし制御を行う分パフォーマンス面に関してはブローカー方式には劣る。またメディエーターと各種イベントプロセッサーは結合しているために、スケーリングの単位がブローカー方式に比べ大きくなってしまうこともデメリットとして挙げられる。

#### エラー処理への対処
イベント駆動アーキテクチャによる非同期処理ではエラー処理をどのように行うかが課題となっている。これに関してはワークフロー移譲を使用することで解決することができる。ワークフロー制御とは、エラーが発生した際にそのことをイベントとしてメッセージキューに送信し、そのエラーイベントを処理するワークフロープロセッサーを別途立てることでエラー処理を行うことである。ワークフロープロセッサーはエラー内容を解析し、正常な状態のイベントに整形してから再びエラーイベントを送信したプロセッサーがサブスクライブしているメッセージキューにそのイベントを送信することで処理を続行する。

#### データロストへの対処
イベント駆動アーキテクチャによる非同期通信ではデータのロストに対しても慎重に扱わなければならない。ここで下記のような構成を考える。
```
<イベントプロセッサーA> -1- <メッセージキュー> -2- <イベントプロセッサーB> -3- <データベース> 
```
ここでデータロストが発生する箇所は以下。
1. A と メッセージキュー間。メッセージキューがクラッシュしている場合や、メッセージキューがイベントを受け取り切る前にAがクラッシュした場合など。
2. メッセージキューとB間。メッセージキューからイベントを処理するまでにBがクラッシュした場合など。
3. Bとデータベース間。データベースへの永続化に失敗する。
1. に関しては同期通信を行うことで解決することが可能。またメッセージキューはイベントを受け取ったらインメモリだけでなくディスクにデータを格納して永続化を行うので、クラッシュした場合もデータのロストは発生しない。2. に関してはクライアント応答モードというモードを使用することで解決できる。クライアント応答モードを使用することで、受け取られたイベントであってもそのままキューに残すことができ、Bがクラッシュした場合でもデータのロストが発生しない。3.に関してはACIDトランザクションを活用することで対応が可能。また、データの永続化が成功した場合に永続化されたキューからイベントを削除するようなLPSという機能も存在する

#### イベント駆動で同期処理を実現したい場合
イベント駆動アーキテクチャは基本的にはリクエスト駆動ではないため、処理としては非同期になるが、同期処理で実装したいケースも場合によっては考えられる。これは相関IDを使用することで実現可能である。
まずイベントプロデューサーがイベントを発行する。この場合IDに一意なものを付与してリクエスト専用のキューに送信する。その後プロデューサーはそのイベントが処理されるまで全体の処理をブロッキングする。この際IDとはまた別の相関IDというものが先ほど設定したIDと同じ値であるイベントがリプライ専用のキューに格納された場合までブロッキングする。イベントコンシューマー側はイベントを受けっとったら処理を実行し、最後に相関IDにIDの値を設定してリプライキューに処理ずみイベントを送信する。

#### 総評
イベント駆動アーキテクチャはパフォーマンス、スケーラビリティ、耐障害性については比較的に高い傾向がある。高パフォーマンスは非同期通信と高い並列性によって実現される。また高スケーラビリティは高度に分割されたプロセッサーによって構成されるので、ロードバランシングが容易となっていることから実現される。また高耐障害性については非同期処理によって後続のプロセッサーが機能しない場合でもクライアントにはレスポンスを返すことができる点によって実現される。その一方で基本的に非同期処理がメインなので単純性とテスト容易性は低い傾向がある。

### マイクロサービスアーキテクチャ
- DDD でいうところの「境界づけられたコンテキスト」に基づいてドメインサービスを構築し、それらを単体のデプロイメントユニットとしてデプロイする。各種ドメインサービスは相互に連携することによってあらゆる機能を実現する。
- 基本的にサービス間の連携には外部通信を行うことになるので通信の信頼性や耐障害性、パフォーマンスなどが問題に挙げられることがある。信頼性や耐障害性に関してはサービスディスカバリの使用やスケーリングによってある程度は解決することができる。パフォーマンスに関しては外部通信を行うたびにセキュリティチェックといったオーバーヘッドがかかるのが原因として挙げられるが、データのキャッシュやレプリケーションを賢く利用することで外部通信を極力抑えることができる。


## 適切なアーキテクチャの選定ができるためには
アーキテクチャの選定に関しては以下の事項を考慮する。
- ドメイン
  - 主要なドメインの側面に関してはある一定の理解をしておく必要がある。
- アーキテクチャ特性
  - そのシステムが満たすべきアーキテクチャ特性を明らかにしておく必要がある。
- データアーキテクチャ
  - 連携するデータベースがどれくらいあるのか、それは新規で構築するのか既存のものを使用するのか
- 組織的な要因
  - 利用を検討しているクラウドベンダーのコストがどれくらいか、また企業がM&Aを計画している場合にはシステムがオープンソースで設計されているかどうか
- 開発チームの開発プロセスが検討しているアーキテクチャにマッチしているか。例えばアジャイル開発に経験がないチームがアジャイル開発に依存したアーキテクチャを採用するのはリスクが高い。

上記を踏まえ、アーキテクチャを検討する際の観点は以下。
- モノリスか分散か
  - シンプルな設計を重視するか、スケールやパフォーマンスの柔軟性を重視するか
- データをどこに置くべきか
  - データ分割の仕方
- サービス間通信は同期か非同期か
  - 非同期通信はパフォーマンスやスケーラビリティの面ではその恩恵を受けることができるが、データの整合性やデバッグ容易性が下がり運用面に課題がある。一方同期通信はスケーラビリティと信頼性は非同期通信には劣るが非同期通信で考慮しなければならないデメリットは考えなくて良い。したがって基本的には同期通信の使用が望ましい。


# チェックリスト

## イントロダクション

- ソフトウェアアーキテクチャを定義する4つの側面は何か
  - 構造
    - アーキテクチャスタイルの種類(マイクロサービス or レイヤード、マイクロカーネルなど)
  - アーキクテチャ特性
    - 非機能要件
  - アーキテクチャ決定
    - 開発チームにおけるコーディングの指針(データアクセスを行うことができるのはサービスとビジネス層に限定する etc...)
  - 設計指針
    - 開発のガイドライン的な立ち位置。遵守することはMUSTではないが、迷った時に意思決定の材料になるもの。
- アーキテクチャ決定と設計指針の違いを説明せよ
  - アーキテクチャ決定は原則的に必ず従うものだが、設計指針はガイドライン的な立ち位置であり遵守するものではない。
- ソフトウェアアーキテクトへの8つの期待を挙げよ
  - アーキテクチャ決定を下す
  - アーキテクチャを継続的に分析する
  - 最新のトレンドを把握し続ける
  - 決定の遵守を徹底する
  - さまざまなものに触れ、経験している
  - 事業のドメインの知識を持っている
  - 対人スキルを持っている
  - 政治を理解し、舵取りをする
- ソフトウェアアーキテクチャの第一法則とは何か
  - ソフトウェアアーキテクチャはトレードオフが全てだ

## アーキテクチャ思考
- アーキテクチャと開発の従来型のアプローチを説明し、そのアプローチがもはや機能しない理由
  - 従来型のアプローチではアーキテクトと開発間に隔たりがあり意思の疎通が難しい体制となっている。アーキテクトを機能させるにはアーキテクトと開発の双方向のコミュニケーションが必須である。
- 知識の三角形における知識の3つのレベルを列挙し、それぞれの例を挙げよ
  - わかっていること、わかっていないとわかっていること、わかっていないとわかっていないこと。
- アーキテクトにとって技術的な深さよりも技術的な幅に焦点を当てることが重要なのはなぜか
  - アーキテクトとしてより多くの選択肢を検討できることが望ましいから。
- アーキテクトとして技術的な深さを維持し、現場感を持ち続けるための工夫にはどのようなものがあるか
  - 概念実証やコードレビュー、生産性向上のための簡単なツールの開発などを行い、コーディングに費やす時間を増やす。

## モジュール性
- コナーセンスとは
- 静的なコナーセンスと動的なコナーセンスの違いは
- 型のコナーセンスは何を意味するか。それは静的なコナーセンスと動的なコナーセンスのどちらかに含まれるか
- コナーセンスの最も強い形は何か
- コナーセンスの最も弱い形は何か
- コードベースで望ましいのは、静的なコナーセンスと動的なコナーセンスのどちらか

## アーキテクチャ特性
- アーキテクチャ特性とみなされる基準を3つ挙げよ
  - ドメインによらない、設計に関する考慮事項を明らかにするもの
  - 設計の構造的な側面に影響を与えるもの
  - アプリケーションの成功に不可欠か重要なもの
- 明示的な特性と暗黙的な特性との違いは何か。それぞれの例を挙げよ
  - 明示的な特性とは既にそれが必要だと明らかになっている特性のことを指す。
  - 暗黙的な特性とは、要件にはあらわれてこないものの、そのシステムに必須である特性のことを指す。例えば証券取引システムを構築する場合、取引の処理は低レイテンシーでなければならないのは設計時に明文化されておらずとも考慮しなければならない特性であると考えられる。
- 運用特性の例を挙げよ
  - 可用性、継続性(障害復旧能力)、パフォーマンス、信頼性/安全性
- 構造特性の例を挙げよ
  - 構造特性はコードの構造に目を向けた特性のことを指す。
  - 構成容易性(アプリケーションの設定が容易にできるかどうか)
  - 拡張性(新しい機能をプラグインで追加する場合の追加容易性)
  - インストール容易性
  - 活用性/再利用性
  - ローカライゼーション
  - メンテナンス容易性
  - アップグレード容易性
- 横断的特性の例を挙げよ
  - アクセシビリティ
  - 長期保存性
  - 認証
  - 認可
  - 合法性
  - プライバシー
  - セキュリティ
  - サポート容易性
  - ユーザビリティ
- 可用性とパフォーマンス、どちらのアーキテクチャ特性を目指すことがより重要か

## アーキテクチャ特性を明らかにする
- アーキテクチャがサポートすべき特性の数を制限することが良い習慣である理由を述べよ
  - サポートする特性が増えると設計段階でシステムの複雑度が高くなるため。
- ほとんどのアーキテえクチャ特性がビジネス要件とユーザーストーリーに由来するというのは正しいか
  - 正しい
- ビジネスのステークホルダーが、市場投入までの時間最も重要なビジネス上の関心ごとだと述べた場合、アーキテクチャはどのアーキテクチャ特性をサポートする必要があるか
  - テスト容易性、デプロイ容易性、アジリティ
- スケーラビリティと弾力性の違いを述べよ
  - スケーラビリティは定常的に使用しているユーザの数から導き出される。一方弾力性とは瞬間的な負荷に耐えられるような構成になっているかどうかの指標である。
- 顧客基盤を大幅に増やすために大規模な買収を行う方針となった。この場合どのようなアーキテクチャ特性を心配する必要があるか
  - 相互運用性、スケーラビリティ、適応性、拡張性

## アーキテクチャ特性の計測と統制
- 循環的複雑度がアーキテクチャを分析する上で重要な指標なのは何故か
  - コードの循環的複雑度が高いとモジュール性、テスト容易性、デプロイ容易性などさまざまな特性に悪影響を与えるため。
- アーキテクチャ適応度関数とは何か。
  - あるアーキテクチャ特性を客観的に評価するために定義される関数。関数自体は作りたいシステムごとに異なる。
- アーキテクチャのスケーラビリティを計測するためのアーキテクチャ適応度関数の例を示せ
  - リクエスト量に応じてキャパシティを増やせるような仕組みが整っているかどうか
- アーキテクトや開発者が適応度関数を作成できるようにするための、アーキテクチャ特性の最も重要な基準は何か
  - モジュール性。各コンポーネントが相互に参照を行っているとあるコンポーネントを使用したい場合は参照している別のコンポーネントも依存関係に加えることになるのでモジュール性が失われ、アーキテクチャは巨大な泥団子アンチパターンに向かうことになる。そうなるとテスト容易性、デプロイ容易性などのさまざまなアーキテクチャ特性に悪影響を及ぼすことになる。

## アーキテクチャ特性のスコープ
- アーキテクチャ量子とは何か。なぜアーキテクチャ量子はアーキテクチャにとって重要なのか
  - 独立してデプロイ可能な、高度な機能的凝集性を持つ、独立してデプロイ可能なコンポーネント。アーキテクチャ量子はアーキテクチャにとって重要なのかはアーキテクチャ量子ごとにアーキテクチャ特性が異なるため。
- 1つのユーザーインターフェースと4つの独立してデプロイされたサービスがあり、各サービスが独立したデータベースを持つシステムがあった場合、アーキテクチャ量子はいくつになるか
  - ユーザインターフェースが各サービスと結合されているので1つ？
- 静的な参照データを管理する管理部門と、発注を管理する顧客対応部門を持つシステムがあるとする。このシステムのアーキテクチャ量子はいくつにすべきか。また、その理由は何か。
  - 2つ？

## コンポーネントベース思考
- アプリケーションやサービスの中で、コンポーネントは通常どのように表現されるか
  - ライブラリ
- 技術による分割とドメインによる分割の違いは何か
  - 技術による分割とは、レイヤードアーキテクチャにおけるプレゼンテーション層、ビジネスロジック層、データ永続化層への分割するような、技術的な関心によって分割することである。一方ドメインによる分割とはビジネスロジックに基づいた分割のことを指す。どちらがいいかはケースによる。
- ドメインによる分割の利点は何か
  - とあるビジネスの関心事毎にコンポーネントが分割されている点。一方技術的な分割では各レイヤーごとにビジネスの関心事に関連した実装を行わなければならない。
- ドメインによる分割よりも技術による分割が望ましいケースは何か
  - 技術による分割はコードをプレゼンテーション、ビジネス、永続化層に分け各層の依存関係を明確にするので、アプリケーションとしては疎結合な構造にすることができる。各層の役割が明確になっているのでコードが整理され理解しやすくなる。

## 基礎
- トレードオフを考えるために、分散コンピューティングの誤信を8つ挙げよ
  - ネットワークは信頼できる
  - レイテンシーがゼロ
  - 帯域幅は無限
  - ネットワークは安全
  - トポロジーは変化しない
  - 管理者は一人だけ
  - ネットワークは均一
- モノリシックアーキテクチャにはない、分散アーキテクチャの課題を3つ挙げよ
  - 分散ロギング
  - 分散トランザクション
  - コントラクトのメンテナンスとバージョン管理

## サービスベースアーキテクチャ
- サービスベースアーキテクチャではデータベースを分解しなければならないか
  - しなくとも良い
- データベースを分解したくなるのはどのような状況か
  - 特定のデータベースに格納されているデータが他のドメインサービスから使用されていない場合
- ドメインサービスの実行にはコンテナが必要か
  - 必要
- サービスベースアーキテクチャはどのようなアーキテクチャ特性を十分にサポートするか
  - アジリティ、テスト容易性、デプロイ容易性
- サービスベースアーキテクチャでは何故弾力性が十分にサポートされていないのか
  - サービスの粒度が粗いため柔軟なスケーリングができないため。
- サービスベースアーキテクチャでアーキテクチャ量子の数を増やすにはどうすればいいか
  - データベースを分割する

## イベント駆動アーキテクチャ
- ブローカートポロジーとメディエータートポロジーの主な違いは何か
  - 全体の処理を管理するメディエーターを置くかどうか
- ワークフローをより良く制御するには、メディエーターとブローカーのどちらのトポロジーを使用すべきか
  - メディエータートポロジー
- ブローカートポロジーは通常、トピックを使用したパブリッシュ/サブスクライブモデルとキューを使用したポイントツーポイントモデルのどちらを活用するか
  - 複数のデプロイメントがサブスクライブする可能性があるのでトピックを使用したモデルが良い
- 非同期通信の主な利点を2つ挙げよ
  - パフォーマンス向上
  - 応答性向上
- キューからメッセージを送受信する際にデータロスを防ぐための技術にはどのようなものがあるか
  - 送信の場合は同期通信、受信の場合はクライアント応答モード
- イベント駆動アーキテクチャを使う際に核となる3つの主要なアーキテクチャ特性は何か
  - パフォーマンス、スケーラビリティ、耐障害性
- イベント駆動アーキテクチャでうまくサポートされないアーキテクチャ特性はどれか
  - 単純性とテスト容易性

## マイクロサービスアーキテクチャ
- 境界づけられたコンテキストの概念はなぜマイクロサービスアーキテクチャにとって重要なのか
  - マイクロサービスはドメインに基づいて分割されるため
- マイクロサービスの粒度が適切なレベルにあるかどうかを判断する3つの方法とは
  - 目的
    - モデル化したいドメインを単位に分割
  - トランザクション
    - データの整合性を担保したい範囲をまとめて一つのマイクロサービスにする
  - コレオグラフィ
    - それぞれのマイクロサービスに分割したとしても、マイクロサービス間の通信が広範囲に及ぶ場合はそれをまとめて一つのマイクロサービスにまとめる
- オーケストレーションとコレオグラフィの違いは何か。マイクロサービスはどちらをサポートしているか。マイクロサービスではどちらのコミュニケーションスタイルの方が容易か。
  - ワークフローを構築する場合に全体の処理を調整する役割を担うメディエーターを置くことがオーケストレーション。メディエーターを置かずに個々のマイクロサービスが連携してワークフローを構築することをコレオグラフィと呼ぶ。コレオグラフィはエラー処理が複雑になる点がデメリットとして挙げられる。またオーケストレーションはメディエーターを置くことでサービス間の結合が発生するが、ドメインのワークフロー自体結合が生じやすいので些細な問題であるため、オーケストレーションの方が採用されることが多い。
- マイクロサービスにおけるサーガとは
  - 複数の処理で構成されるトランザクションにおいて途中の処理で失敗した場合に成功した処理を打ち消す操作を実行すること。
- 一般にマイクロサービスでパフォーマンスが問題になる理由を2つ挙げよ
  - 外部のコンポーネントとの通信が増え、通信コストが大きくなる
  - 各通信でセキュリティチェックが必要となる
- マイクロサービスはドメインによって分割されたアーキテクチャか、それとも技術によって分割されたアーキテクチャか
  - ドメイン
- マイクロサービスでは、ドメインの再利用はどのように扱われるか
  - サイドカーによって実現される

## 適切なアーキテクチャスタイルを選ぶ
- データアーキテクチャは、どのような方法でアーキテクチャスタイルの選択に影響を与えるか
- 上記は使用するアーキテクチャスタイルの選択にどのような影響を与えるか
- アーキテクチャスタイル、データ分割、通信スタイルを決定する際にアーキテクトが用いる手順を説明せよ
- アーキテクトを分散アーキテクチャに向かわせる要因は何か

## アーキテクチャ決定
### アンチパターン
- 資産防御アンチパターン
  - (概要) 問題が発生することを恐れてアーキテクチャの決定を先延ばしにすること
  - (対策) アーキテクチャの決定に期限を設ける。開発側と協力し問題が発生したとしても早期に対処できるような体制を整えておく
- グラウンドホックデーアンチパターン
  - (概要) アーキテクチャを決定したのちになぜそのようなアーキテクチャとなったのかがわからずに何度も議論がされてしまうこと
  - (対策) なぜそのような決定を行なったのかを技術面、ビジネス面から説明できるようにしておく。もしくは文書化しておく
- メール駆動アンチパターン
  - (概要) アーキテクチャを理解していなかったり忘れていたりして実装ができないパターン
  - (対策) テキストベースでは伝わりづらいので資料としてまとめておく

### アーキテクチャ上重要なもの
- 重要なものは以下の項目に影響を与えるもの
  - 構造
    - アーキテクチャパターンなど
  - 非機能要件
  - 依存関係
    - コンポーネントやコードレベルのもの様々
  - インターフェース
  - 構築手法
    - プラットフォーム、フレームワーク

### アーキテクチャデシジョンレコード
- アーキテクチャの決定を文書化したもの
  - タイトル(ぶれなく、簡潔に)
  - ステータス(承認済み、破棄)
  - コンテキスト(その決定を行なった背景)
  - 影響(このアーキテクチャ決定がどのような影響をもたらすのか)
  - コンプライアンス(そのアーキテクチャ決定が順守されていることを確認する方法。手動での確認でも可)
  - 備考(この決定が承認された日)

## アーキテクチャ上のリスクを分析する

### リスクマトリックス
- リスクを分析する場合は以下の2軸で考える
  1. リスクが発生した場合の全体的な影響(低/中/高)
  2. リスクが発生する可能性(低/中/高)
- 1 * 2 で全体的なリスクの大きさを定量化する

### リスクアセスメント
- 各コンポーネントごと、加えて各アーキテクチャ特性ごとにどれくらいのリスクが存在するか、そしてそれが減少傾向にあるのかそれとも増加傾向にあるのかを表としてまとめる。

### リスクストーミング
- 実際にシステムのどの箇所にリスクが潜んでいるのかをシステム構成を見ながらメンバーで洗い出す作業。大まかに3つのステップに分かれる
  - 特定: 各メンバーがシステムのどこにリスクが潜んでいるのか、そしてそのリスクがどれくらいなのかを洗い出す。
  - 合意: 各メンバーが洗い出したリスクに関してメンバー全体としての意見を出す。意見が食い違った場合はなぜそう考えたのかを説明して認識合わせを行う。
  - 軽減: 最終的に出したリスクに対して解決策を検討する。この際に解決のためにどれくらいの工数や費用が必要なのかをまとめておくとビジネスのステークホルダーへの説明に役立つ。

### ユーザーストーリーリスク分析
- 可用性
  - 複数のコンポーネントから参照されるデータベースが存在する場合、可用性を考慮して分割できるのであれば分割する。
  - 外部APIなど自分たちでは可用性を調整できない箇所が存在しない場合はSLAがどれくらいなのかを調査しておく。その調査結果に基づいて何か追加で対策が必要かを検討する。
- 弾力性
  - ピーク時のリクエスト(日ごとのピークではなく、時期的なピークも含む)を捌ききれないパフォーマンスであった場合、リクエスト量をパフォーマンスの限界に合わせるか、もしくはリクエストを少なくする対応が必要。前者はリクエストのキューイングを行いリクエスト量を一定量にするなどが考えられる(ただユーザはアクセスに時間がかかる事になる)。後者はキャッシングを行うことで実現できる。
- セキュリティ
  - 許可していないユーザに対してアクセスを許可してしまわないように、各システムのエンドポイントやAPIゲートウェイは極力分割する。