
# ソフトウェアアーキテクチャの責務

## ソフトウェアアーキテクチャの構成要素
- システムの構造
  - アーキテクチャスタイルのこと(マイクロサービス、レイヤード etc...)
- アーキテクチャ特性
  - システムの機能とは直接は関係しないが、システムの成功基準を定義する上で考慮しなければならないこと。非機能要件みたいなもの？(可用性、スケーラビリティ、パフォーマンス etc...)
- アーキテクチャ決定
  - どのようにシステムを構築するのかをコードレベルで考えること(レイヤードアーキテクチャで構築する場合はビジネス層とサービス層のみデータベースにアクセスでき、プレゼンテーション層はアクセスを行わないようにする)。そして決定した方針をメンバーに順守させること。
- 設計指針
  - 開発におけるガイドラインを提供すること。基本的に決定した方針を順守させるアーキテクチャ設計とは異なり、より望ましいアプローチを提供するといったような緩さのもの(REST or Grpc)。

## アーキテクチャに期待すること
- アーキテクチャ決定を下す
  - 特定の技術を使用することを指示するのではく、構築するシステムに対して望ましい特性を持つ技術を使用することを指示する(React を使用するように指示するのではなく、リアクティブベースのフレームワークを使用することを指示する)。
- アーキテクチャを継続的に分析する
  - すでにリリースされているシステムに対して、適用されているアーキテクチャが最適かどうかを継続的に分析することが求められる。
- 最新のトレンドを把握し続ける
  - 自明なので省略
- 決定の順守を徹底する
  - レイヤードアーキテクチャを採用しているのにもかかわらず、データベースへのアクセスをプレゼンテーション層に実装することのないようにといったような、指針の順守を徹底させる
- 様々なものに触れ、経験している
  - アーキテクトにおける引き出しを増やしておく。この点に関しては技術的な深さよりも幅を優先するように知識を習得するのが望ましい。
- 事業ドメインの知識を持っている
  - 対象となるサービスの知識を理解していないと最適なアーキテクチャを検討することは難しい。金融システムのアーキテクチャを検討するにあたり、金融用語を知っていないとどのようにシステムを構築すればいいのか見当もつかないし、ステークホルダーとのこのコミュニケーションもうまくいかない可能性がある。
- 対人スキルを持ち合わせている
  - チームへの指導や設計指針の伝達など、アーキテクチャには対人スキルを求められる場面が多い。
- 政治を理解し、舵取りをする
  - 考案したアーキテクチャで開発を進めるためにプロジェクトマネージャ、ビジネスサイド、または開発者を納得させねばならない。

## アーキテクチャと交わるもの

### エンジニアリングプラクティス
- 問題を解決しようとしている領域に適したシステムアーキテクチャがあるのと同様に、特定のシステムアーキテクチャに適したエンジニアリングプラクティス(開発プロセスのことを指す。具体的には CI/CD の導入など)も存在する。したがって開発者は採用するアーキテクチャに適したエンジニアリングプラクティスを実施するのが望ましい。例えばマイクロサービスアーキテクチャはここのシステムの規模が小さいので開発のイテレーションを重ねていくことになるためCI/CDの導入は必須である。
- また運用していく上でシステムのアーキテクチャは開発を重ねていくたびに変化していくことになるので、定期的にシステムのアーキテクチャ特性が十分かどうかを確認する必要がある。確認するためにはアーキテクチャ適応度関数という考え方を取り入れることが望ましい。アーキテクチャ適応度関数とはそのシステムのアーキテクチャ特性を定量化したものである。例えば、とあるシステムでページの読み込み時間をなるべく短くすることに関心がある場合、その読み込み時間を計測するようなテストなりメトリクスを用意して常にモニタリングできるような体制を整えておくといった取り組みが該当する。

# 1部 アーキテクトに必要な考え方
## アーキテクチャ思考とは
- アーキテクチャ思考とは以下の5つ要素で構成される

### 開発側との相互的な連携を行う
- 従来は問題領域に対応したシステムのアーキテクチャをアーキテクトが考え、実際のシステムの構築は開発側に委ねるような体制が一般的であったが、昨今ではそういったアーキテクトと開発側の壁は取り払い共同してシステムの開発に取り組むことが求められる。

### 技術的な深さではなく幅を広げることを意識する
- 問題領域に適したアーキテクチャを考案する場合には、多くの選択肢を提示できるアーキテクトである方が望ましい。したがって特定の技術に特化した知識を身につけるよりも様々な知識を知っている方がアーキテクトとしては重宝される。

### トレードオフを分析する
- 問題領域における特有の事情と採用する技術を考慮し、検討しているアーキテクチャのメリット・デメリットを考えて各アーキテクチャを評価することが必要。

### ビジネスドライバーを理解する
- ビジネスを成功させるために考慮すべき要素をアーキテクチャ特性に変換するスキルや、それを定期的に評価する方法を検討する必要がある。

### アーキテクティングとコーディングのバランスをとる
- 開発側との共同が必要となってくるために、アーキテクトにも現場感覚を持つことが重要となってくる。したがって概念実証や些細な改修や開発生産性向上のためのツールの導入、コードレビューなどを行うことで現場感を養うことが重要。


# 2部 アーキテクチャスタイル

## 基礎
### 分散型のデメリット
- パフォーマンス、スケーラビリティ、可用性は分散型の方が優れている
- ネットワークの信頼性や安全性に比例してサービスのクオリティが変化してしまうのが分散型のデメリット
- レイテンシに関しては分散型よりもローカル通信で完結するモノリシック型の方が小さくなる傾向がある
- 使用する帯域幅はモノリシックの方が小さい
- ログが分散しているため原因の特定が難しい
- トランザクションの管理が難しいのでデータの整合性や完全性を担保することが難しい

## 各種アーキテクチャ

### レイヤードアーキテクチャ
- 小規模でシンプルなアプリケーションを開発する際に適しているアーキテクチャ。ただだんだんシステムが複雑化してくると他のアーキテクチャに乗り換える必要がでてくる。
- モノリシックなアプリケーションであることやモジュール性の欠如が原因で弾力性とスケーラビリティは低い。
- パフォーマンスも開発側が工夫しなければ決して優れているとは言えない。
- モノリシックなアプリケーションから耐障害性も高いとは言えない。システムの一部でメモリ不足が発生した場合にシステム全体がダウンする。

### サービスベースアーキテクチャ
- 複数のユーザインターフェース、複数のコンポーネント(基本的には各コンポーネントはレイヤードアーキテクチャで実装されている)、単一のデータベースが基本形となる。ただしデータベースに関してもドメインごとに分割する方法も存在する。
- マイクロサービスアーキテクチャと異なる点としては、ドメインサービスの粒度がマイクロサービスアーキテクチャと比べて粗くなる点と他のドメインサービスの呼び出しにおいては外部通信を用いるのではなく、内部でのクラスの呼び出し、もしくは内部間通信でもって実行される点である。これによるメリットとしてはデータの整合性を保てる点が挙げられる。マイクロサービスアーキテクチャでは基本的にはBASEトランザクションであることに比べ、サービスベースアーキテクチャは各ドメインサービスごとにトランザクションを管理するためACID特性を保つことができる傾向がある。また基本的にサービス間通信はローカルになるので帯域幅を節約できるのもメリットである。
- また各ドメインサービスごとにデプロイメントユニットが分割されている場合にはスケーリングを柔軟に行うことができる点もメリットとして挙げられる。
- 逆にマイクロサービスアーキテクチャよりも劣っている点としてはテストの実行難易度や改修の難易度はサービスベースアーキテクチャの方が高くなる傾向がある。これはサービスの粒度がマイクロサービスアーキテクチャよりも粗いために、些細な改修でも影響する範囲が大きくなってしまいデプロイまでの時間がかかりアジリティが損なわれてしまう懸念がある。

### イベント駆動アーキテクチャ
ほとんどのシステムがUIの操作から実行されるリクエストを処理するリクエストベースのアーキテクチャで構築されていることに対し、イベント駆動アーキテクチャとは何かしらのイベントが発行された場合に、イベントを処理する複数のイベントプロセッサーが処理を行ってサービスにおけるとある機能を実現する。例としてはオークションにおける入札機能が挙げられる。個々の入札リクエストを処理するのではなく、希望価格が提示された場合に、現状の入札状況を考慮して最高額を提示した入札者を決定するような処理はイベント駆動で処理されることが望ましい。

#### イベント駆動アーキテクチャにおける2つのトポロジー

##### ブローカー
ブローカー方式のイベント駆動アーキテクチャとはそれぞれイベントを処理するイベントプロセッサーがメッセージキューなどのブローカーを介して相互に連携する方式のことを指す。オンラインのショッピングシステムを例に取った場合、注文を行うことで一番最初のイベントが発行される。その後注文イベントを処理するプロセッサーがメッセージキューに注文イベントをキューイングする。その後、注文を受け付けたことをメールで送信する処理を実行する通知イベントプロセッサーや、注文内容に基づいて決済を行う決済イベントプロセッサーが注文イベントをメッセージキューからサブスクライブしてそれぞれの処理を実行する。
ブローカー方式のメリットとしてはそれぞれのイベントプロセッサーはそれぞれ独立して動いているため、システムとしては疎結合なつくりとなりパフォーマンスや応答性、スケーラビリティがが優れている点が挙げられる。一方デメリットとしてはそれぞれのイベントプロセッサーが独立して動いているため、最終的に処理が成功したかどうかは知る由がないことが挙げられる。またそれぞれがメッセージキューを介してのみイベントを受け取るために、イベントを送信したプロセッサーが正常に動いているかどうかもわからないので、エラー処理が難しくなる点もデメリットの一つである。

##### メディエーター
メディエーター方式はブローカー方式のデメリットを解消するような構成となっている。開始イベントをメッセージキューに送信するところは同じだが、メディエーター方式ではその開始イベントをメディエーターと呼ばれる全体の処理を制御するプロセスが受け取る。イベントを受け取ったメディエーターは処理の完了に必要なイベントプロセッサーに対して、メッセージキューを介して全体の処理を実行していく(メッセージの送信は機能によって同期/非同期に分かれる)。イベントメディエーターは単純な処理に関しては自分で処理するなりイベントプロセッサーに渡すなりするが、処理が難しい場合は他のイベントメディエーターにイベントを送信するといったことも行う。
全体の処理を制御するメディエーターを置くことで、ブローカー方式に比べエラー処理が容易になることがメディエーター方式のメリットである。ただし制御を行う分パフォーマンス面に関してはブローカー方式には劣る。またメディエーターと各種イベントプロセッサーは結合しているために、スケーリングの単位がブローカー方式に比べ大きくなってしまうこともデメリットとして挙げられる。

#### エラー処理への対処
イベント駆動アーキテクチャによる非同期処理ではエラー処理をどのように行うかが課題となっている。これに関してはワークフロー移譲を使用することで解決することができる。ワークフロー制御とは、エラーが発生した際にそのことをイベントとしてメッセージキューに送信し、そのエラーイベントを処理するワークフロープロセッサーを別途立てることでエラー処理を行うことである。ワークフロープロセッサーはエラー内容を解析し、正常な状態のイベントに整形してから再びエラーイベントを送信したプロセッサーがサブスクライブしているメッセージキューにそのイベントを送信することで処理を続行する。

#### データロストへの対処
イベント駆動アーキテクチャによる非同期通信ではデータのロストに対しても慎重に扱わなければならない。ここで下記のような構成を考える。
```
<イベントプロセッサーA> -1- <メッセージキュー> -2- <イベントプロセッサーB> -3- <データベース> 
```
ここでデータロストが発生する箇所は以下。
1. A と メッセージキュー間。メッセージキューがクラッシュしている場合や、メッセージキューがイベントを受け取り切る前にAがクラッシュした場合など。
2. メッセージキューとB間。メッセージキューからイベントを処理するまでにBがクラッシュした場合など。
3. Bとデータベース間。データベースへの永続化に失敗する。
1. に関しては同期通信を行うことで解決することが可能。またメッセージキューはイベントを受け取ったらインメモリだけでなくディスクにデータを格納して永続化を行うので、クラッシュした場合もデータのロストは発生しない。2. に関してはクライアント応答モードというモードを使用することで解決できる。クライアント応答モードを使用することで、受け取られたイベントであってもそのままキューに残すことができ、Bがクラッシュした場合でもデータのロストが発生しない。3.に関してはACIDトランザクションを活用することで対応が可能。また、データの永続化が成功した場合に永続化されたキューからイベントを削除するようなLPSという機能も存在する

#### イベント駆動で同期処理を実現したい場合
イベント駆動アーキテクチャは基本的にはリクエスト駆動ではないため、処理としては非同期になるが、同期処理で実装したいケースも場合によっては考えられる。これは相関IDを使用することで実現可能である。
まずイベントプロデューサーがイベントを発行する。この場合IDに一意なものを付与してリクエスト専用のキューに送信する。その後プロデューサーはそのイベントが処理されるまで全体の処理をブロッキングする。この際IDとはまた別の相関IDというものが先ほど設定したIDと同じ値であるイベントがリプライ専用のキューに格納された場合までブロッキングする。イベントコンシューマー側はイベントを受けっとったら処理を実行し、最後に相関IDにIDの値を設定してリプライキューに処理ずみイベントを送信する。

#### 総評
イベント駆動アーキテクチャはパフォーマンス、スケーラビリティ、耐障害性については比較的に高い傾向がある。高パフォーマンスは非同期通信と高い並列性によって実現される。また高スケーラビリティは高度に分割されたプロセッサーによって構成されるので、ロードバランシングが容易となっていることから実現される。また高耐障害性については非同期処理によって後続のプロセッサーが機能しない場合でもクライアントにはレスポンスを返すことができる点によって実現される。その一方で基本的に非同期処理がメインなので単純性とテスト容易性は低い傾向がある。

### マイクロサービスアーキテクチャ
- DDD でいうところの「境界づけられたコンテキスト」に基づいてドメインサービスを構築し、それらを単体のデプロイメントユニットとしてデプロイする。各種ドメインサービスは相互に連携することによってあらゆる機能を実現する。
- 基本的にサービス間の連携には外部通信を行うことになるので通信の信頼性や耐障害性、パフォーマンスなどが問題に挙げられることがある。信頼性や耐障害性に関してはサービスディスカバリの使用やスケーリングによってある程度は解決することができる。パフォーマンスに関しては外部通信を行うたびにセキュリティチェックといったオーバーヘッドがかかるのが原因として挙げられるが、データのキャッシュやレプリケーションを賢く利用することで外部通信を極力抑えることができる。


## 適切なアーキテクチャの選定ができるためには
アーキテクチャの選定に関しては以下の事項を考慮する。
- ドメイン
  - 主要なドメインの側面に関してはある一定の理解をしておく必要がある。
- アーキテクチャ特性
  - そのシステムが満たすべきアーキテクチャ特性を明らかにしておく必要がある。
- データアーキテクチャ
  - 連携するデータベースがどれくらいあるのか、それは新規で構築するのか既存のものを使用するのか
- 組織的な要因
  - 利用を検討しているクラウドベンダーのコストがどれくらいか、また企業がM&Aを計画している場合にはシステムがオープンソースで設計されているかどうか
- 開発チームの開発プロセスが検討しているアーキテクチャにマッチしているか。例えばアジャイル開発に経験がないチームがアジャイル開発に依存したアーキテクチャを採用するのはリスクが高い。

上記を踏まえ、アーキテクチャを検討する際の観点は以下。
- モノリスか分散か
  - シンプルな設計を重視するか、スケールやパフォーマンスの柔軟性を重視するか
- データをどこに置くべきか
  - データ分割の仕方
- サービス間通信は同期か非同期か
  - 非同期通信はパフォーマンスやスケーラビリティの面ではその恩恵を受けることができるが、データの整合性やデバッグ容易性が下がり運用面に課題がある。一方同期通信はスケーラビリティと信頼性は非同期通信には劣るが非同期通信で考慮しなければならないデメリットは考えなくて良い。したがって基本的には同期通信の使用が望ましい。


# チェックリスト

## イントロダクション

- ソフトウェアアーキテクチャを定義する4つの側面は何か
  - 構造
    - アーキテクチャスタイルの種類(マイクロサービス or レイヤード、マイクロカーネルなど)
  - アーキテクチャ特性
    - 非機能要件
  - アーキテクチャ決定
    - 開発チームにおけるコーディングの指針(データアクセスを行うことができるのはサービスとビジネス層に限定する etc...)
  - 設計指針
    - 開発のガイドライン的な立ち位置。遵守することはMUSTではないが、迷った時に意思決定の材料になるもの。
- アーキテクチャ決定と設計指針の違いを説明せよ
  - アーキテクチャ決定は原則的に必ず従うものだが、設計指針はガイドライン的な立ち位置であり遵守するものではない。
- ソフトウェアアーキテクトへの8つの期待を挙げよ
  - アーキテクチャ決定を下す
  - アーキテクチャを継続的に分析する
  - 最新のトレンドを把握し続ける
  - 決定の遵守を徹底する
  - さまざまなものに触れ、経験している
  - 事業のドメインの知識を持っている
  - 対人スキルを持っている
  - 政治を理解し、舵取りをする
- ソフトウェアアーキテクチャの第一法則とは何か
  - ソフトウェアアーキテクチャはトレードオフが全てだ