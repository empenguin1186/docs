# 境界づけられたコンテキスト

- システムを構築する際にはドメインを関心ごとを基準に分割する必要がある。これは関心ごとが衝突していると修正の障害となるからためである。
- ソフトウェアが解決する領域のことをドメインと呼ぶ。その中でも、競合優位性が高いといったある観点で重要となってくるドメインのことをコアドメインと呼ぶ。これを優先してモデリングを行っていくことになる。
- 関心ごとに基づいて分割された個々のドメインのことをサブドメインと呼ぶ。大抵システムは複数のサブドメインから構成される。
- サブドメインの中でも業務ロジックではないが業務ロジックを実現するためのアルゴリズムなどがまとめられているサブドメインはモジュールとして扱う方が良い
- 各サブドメインは他のサブドメインと連携して一つのドメインを実現するが、サブドメインごとの連携方法にもさまざま存在する。これをコンテキストマップと呼ぶ。
- 自分たちで境界づけられたコンテキストを可視化してみるのもいい経験になる。

- 問題空間と解決空間
  - 問題空間とは新しいコアドメインを生み出すために開発を要するところ。既存のサブドメインに加えて、今後必要になるサブドメインも検討する必要がある
  - 解決空間とは境界づけられたコンテキストのことを指す。境界づけられたコンテキストは特定のソリューションをソフトウェアとして具現化したもの。
- ライフサイクル(境界づけられたコンテキスト)によって違ったモデリングとなる
  - 書籍の例
    - 書籍を出版する出版社の業務フローは大体以下のようなステップに分けられる
      - 書籍の内容を案としてまとめ、起案する
      - 著者と出版契約を結ぶ
      - 書籍の執筆と編集のプロセスを管理する
      - 書籍をデザインする
      - 書籍を他言語に翻訳する
      - 紙の書籍や電子版を作成する
      - 書籍を宣伝する
      - 書籍を再販業者に販売する
      - 紙の書籍を再販業者や顧客に出荷する
    - 各ステップで「書籍」の定義は異なるので、共通の書籍モデルを扱ってしまうと無理が生じるケースがほとんどである。したがって各ステップ(コンテキスト)ごとに書籍のモデリングを行うのが効果的である。各ステップ間で書籍の情報を共有したい場合は、書籍に識別子を持たせておいてそれをキーに各ステップで書籍のモデルを構築するような実装を行う(識別子は最初の起案ステップで発行し、以降それを各ステップで使用する)。
  - コンテキストのスコープ
    - データベーススキーマにドメインの概念が含まれる(カラム名がユビキタス言語で表されている etc...)場合は、そのDBも同じコンテキストに含まれる。そうでない場合はDBはコンテキストには含まれない
    - 同じく UI にドメインの概念が含まれる場合も UI もそのコンテキストに含まれる。しかし、UI は技術的な関心ごとがメインであることに加え、UI にドメインのロジックを含めるとドメインロジック貧血症を起こすことになったりドメインロジックの置き場所が散財するので望ましくない。
  - コンテキストの大きさ
    - ユビキタス言語の全てを表現できる範囲でのモデリングをすべきである。不要な概念やモデルは含めるべきではない
  - そのコンテキストで真に必要な概念は何かを検討し、もしそれにそぐわないモデルが存在する場合は別のモジュールやコンテキストに切り分ける必要がある。

# コンテキストマッピング
- あるドメインにおいて各コンテキスト間の関連を可視化することをコンテキストマッピングと呼ぶ。コンテキストマッピングを行う目的としては、各コンテキスト間の関連を可視化することで解決空間の全貌を俯瞰できるようにすることである。
- 2つのコンテキストの関連には以下のようなパターンが存在する
  - パートナーシップ
    - それぞれのコンテキストを担当するチームが共同して開発を進めるパターン
  - 共有カーネル
    - 2つのコンテキスト間で同じモデルを使用する。一方がモデルを修正する場合はもう一方の許可なくしては修正を行ってはならない(共有モデルの修正がもう一方の実装に影響を及ぼすため)。
  - 顧客/供給者の開発
    - 上流(供給者)が顧客(下流)の要望を聞いて開発を行うパターン。
  - 順応者
    - 上流が下流の要望を聞かないパターン。下流はただただ上流で行われた修正を取り込むのみ。
  - 腐敗防止層
    - 上流から提供されるオブジェクトモデルを自身のドメインの関心ごとに合致させるためにオブジェクトの変換を行う。
  - 公開ホストサービス
    - もう一方のコンテキストからアクセスできるように REST や メッセージングなどでサービスを公開する。
  - 公表された言語
    - 2つのコンテキストで定義されているモデルの変換を行えるように各モデルに変換可能な共通の言語を定義すること。公開ホストサービスと併用されるケースが多い。
  - 巨大な泥団子 -> 学ぶ意味なし
  - 別々の道 -> 学ぶ意味なし
- 単体のコンテキストの処理が関連する他のコンテキストの稼働状態に極力依存しないような実装にしたい場合
  - 関連するコンテキストのサービス状態が自分たちのコンテキストの処理の成否に影響を及ぼすような事態は極力避けたい。自立性を確保するためには、他のコンテキストから取得するような情報をローカルにキャッシュするのが一つの解決策となる。その場合、定期的に外部のコンテキストへのリクエストを実行し、取得した情報をもとに自分たちのモデルを更新するようなことを行えば良い。

# アーキテクチャ
- 何かしらのアーキテクチャを選定する際には正当な根拠が必要
- レイヤ化アーキテクチャ
  - 構成レイヤ
    - ユーザーインターフェースレイヤ
      - ユーザインターフェースレイヤで実装するバリデーションについてはドメインのロジックを実装するまでは必要ない。緩いチェックで済ませる。
    - アプリケーションレイヤ
      - 基本的にドメインロジックを呼び出すだけにとどめる。ドメインロジックを実装しない。モデルのユースケースやユーザストーリーを表現するためのレイヤ。
    - ドメインレイヤ
      - ドメインロジックを実装する場所
    - インフラストラクチャレイヤ
      - 特定のデータストアに対応するデータ永続化などのロジックを実装する
  - 依存性逆転の原則
    - 上位の層(ドメイン、アプリケーション)は下位の層(インフラストラクチャ)に依存してはならない。抽象は、実装の詳細に依存するのではなく、実装の詳細が抽象に依存すべきである。
- ヘキサゴナルアーキテクチャ
  - 入力形式や出力形式ごとにポート(アクセスポイント)とアダプタ(ドメインロジックで処理できるオブジェクトに変換する役割を担うオブジェクト)を定義して外部から内部のドメインロジックを守る設計。
- サービス指向アーキテクチャ
- コマンドクエリ責務分離(CQRS)
  - どんなケースで有効か
    - 複数のリポジトリを使用しなければならないケースといったように、データを構築するのに複雑な工程を踏まなければならないケースが存在する。もちろん関連する全てのリポジトリからデータを取得してモデルを組み立てることが可能であればそれでもいいが、必ずしもそうはいかないケースが存在する。このような場合に CQRS が有効となる。
    - 単一のビューに複数の集約が関連することがなければ CQRS はただ単にシステムを複雑にするだけなので使用は避けた方がいい。
  - 原則
    - メソッドにはデータの更新といった何かしらのアクションを起こす操作を「コマンド」、データの取得を行う「クエリ」の両方の機能を持たせてはならない。すなわちクエリを実行する際にはデータの更新などの副作用を必ず起こしてはならない。Java でいうとコマンドの実装をする場合はメソッドの戻り値は void で定義し、クエリを実装する際には対応する型を返さなければならない。
  - 構成要素
    - クエリプロセッサ
      - 基本的にデータベースに問い合わせることを目的としたオブジェクト。クライアントがデータを取得したい際に利用されるオブジェクト。データベースに格納されているデータは UI 観点で扱いやすい構造となっているため、改めてクエリプロセッサでモデルの再構築を行う必要はない。ただ必要になった場合は DTO を使用して扱いやすい形式でクライアントに返す。
    - クエリモデル(リードモデル)
      - 表示に特化したデータモデル。表示のしやすさに特化しているので正規化はされていない。ビューを使用することにより例えばユーザ属性別のデータを提供することも可能。
    - コマンドプロセッサ
      - ユーザが発行したコマンドをハンドリングするオブジェクト。ハンドリングの方法はさまざまある。一つのハンドラで全てのコマンドをハンドリングする方法や、個々のコマンドをハンドリングするハンドラを複数定義する方法、またはコマンドが発行されたことをイベントとしてそれをサブスクライブするような非同期の方法も存在する。ただ非同期処理にする場合はスケーラビリティに懸念がある場合に使用するのが望ましい。
    - コマンドモデル(ライトモデル)
      - 実際にコマンドによりデータを更新するモデル。コマンドの実行履歴は別途データベースで永続化する。コマンドを実行した後はイベントを発行してそれをサブスクライブしているサブスクライバがその情報をもとにクエリモデルを更新する。これによりデータの同期が行われる。コマンドによるデータの更新と、サブスクライバによるクエリモデルの更新は同期処理で実行することもできるが、これは構築するシステムの要件と相談してどれくらいの同期レベルまで担保するかで変わってくる。更新を同期する場合はコマンドモデルとクエリモデルで同じデータベースを共有するのが一般的である。
    - クエリモデルの結果整合性
      - クエリモデルの更新に時間がかかる場合は以下のような回避策が考えられる。
        - 一時的に更新に使用したデータをUIに表示させる
        - クエリモデルに更新された日時を記録させておき、UIに表示させる(最新のデータなのかの判断に使用する)
          - ユーザ受け入れテストを行ってから最終的に導入するかどうかは決めた方がいい。
- イベント駆動アーキテクチャ
  - 概要
    - 特定のイベントを購読して(入力イベント)何かしらの処理を行い、その後イベントを発行する(出力イベント)フィルタというコンポーネントを組み合わせることにより全体の処理を実現するアーキテクチャ。フィルタ全体のことをパイプラインと呼ぶ。
  - メリット
    - 柔軟性が高い点。パイプラインにフィルタを追加したい場合、新しいイベントを発行しそれを追加したフィルタに購読させるようにすればいい。この場合適用するフィルタの順番については十分に考慮しておく必要がある。
  - 長期プロセス
    - 構築するパイプラインは必ず1つであるとは限らない。時には複数のパイプラインの最終結果を組み合わせて何かしらの処理を実行する必要がある。この場合整合性を保つために、イベントが発行されたら一意に特定できる識別子を付与しておくと管理が可能となる。また、各フィルタで処理が完了した際に発行されるイベントを購読して状態を変更させることで、一連の処理がどこまで進んでいるのかを追跡することができる。
- イベントソーシング
  - 概要
    - ドメインオブジェクトに関する変更を追跡したいようなケースがあったとする。この場合、git のバージョン管理のように、ドメインオブジェクトに対して行った変更(イベント)をデータストアなどに保存しておくとよい。万が一にある時点での状態に戻したいようなケースに遭遇した場合に、データストアに格納されているイベントを順番に適用することで状況を再現することができる。
  - 気をつける点
    - 一回の操作で大量のイベントが保存されるケースも考えられるため、イベントを保存するタイミングは慎重に検討する。
  - 技術的面以外のメリット
    - ある特定の状況を再現することができる。また再現する過程も一度実行されているものであり何をやっているかが明確で法的にも安心できる。
    - モデルへの変更や取り消しもやり直しもできる
    - 履歴を管理しているため、検証しやすい(もしこんな状況だったら？)

# ドメインイベント
- なぜドメインイベントを使用するのか
  - 業務フローの中で「〇〇の場合に××といった処理を行う」というようなユースケースが存在した場合にドメインイベントとして実装するのが効果的なケースがある。ドメインイベントとして定義することで、そのイベントを購読するさまざまなサブスクライバを実装することによりドメインイベントを起点にさまざまな処理を実装することが可能となる。こういった再利用性の観点からドメインイベントは実装パターンとして効果的なものである。
- ドメインイベントパブリッシャーは集約に対してドメインイベントを発行しサブスクライバに通知を行うことができるシンプルなインターフェースを提供する
- サブスクライバの登録は基本的にはアプリケーションサービスが行う。
- サブスクライバの処理は単一の集約に対して状態を変更させることに留めること。複数の集約の状態を1つのサブスクライバの処理で実行することは望ましくない。
- ドメインモデルが使用する永続化ストアと、イベントをメッセージング基盤が転送する際に使用される永続化ストアの整合性は保たなければならない。保つ方法としては以下。
  - 2つの永続化ストアが共有のデータソースを使用するようにする。
  - 2つの永続化ストアをグローバルな XA トランザクションで制御する。
    - グローバルなトランザクションに対応していないものもある。
  - イベントストアを使用する。
    - TODO
- イベントストア
  - 概要
    - イベントストアとは、ある境界づけられたコンテキストで発行されたドメインイベントの内容を格納するデータストアのことを指す。イベントストアを利用するメリットは以下。
      - イベントストアにメッセージングキューを採用した場合、サブスクライバを登録することで特定のドメインイベントが発行された際に何かしらのアクションを実行できるようになり、ビジネスロジックの拡張につながる
      - モデルに対して実行された全てのコマンドを記録することで障害時のデバッグが容易となる。
      - 全てのドメインイベントを記録することで、何がどのような処理を行ったかが明確になる(監査ログ的な役割)
      - ドメインイベントの履歴が蓄積されるので、データ分析が可能となる。
      - オブジェクトをある特定の状態に変更することができたり、ある特定の時点以降の変更を取り消すことも可能となる。
  - イベントの取得方法
    - RESTを使用した方法
      - ある一定の周期でイベントストアにイベント履歴を取得しに行く方法。設定次第ではポーリングのアクセスがいたずらに増えトラフィックが増大してしまう懸念があるが、クライアント/サーバ側でキャッシュを利用することによりある程度負荷を軽減することが可能。
    - メッセージングミドルウェアを使用した方法
      - ドメインイベントパブリッシャーがサブスクライバに対してメッセージを送信する。なおパブリッシャーはメッセージングミドルウェアにイベントを送信するまでが責務となる。
- イベントの重複排除
  - 重複が発生するケース
    - MQ がサブスクライバにメッセージを送信 -> サブスクライバがメッセージを処理 -> サブスクライバがメッセージの受領と処理の完了の応答を返す前に異常終了 -> MQ はサブスクライバから応答が返ってこないのでメッセージを再送
    - メッセージングシステムとイベントストアが永続化メカニズムを共有していないかつ、イベントストアとメッセージングシステムの変更がアトミックに行われていないようなケース
  - 重複が発生した場合の対処方法
    - 同じイベントに対する操作が複数回実行されたとしても処理自体は1回しか行われないようにする(冪等性)。イベント発行側が冪等性を担保するにはサブスクライバの状態を知っていなければならないので結合度が高くなり望ましくない。従って各サブスクライバ側がどのイベントを処理したかの履歴を保持して冪等性を担保するのが望ましい。使用するメッセージングミドルウェアがこの辺りの処理をどう実装しているかを確認する必要がある。また遅延や再送などの影響でイベントが発行された順番通りにサブスクライバが処理するとは限らないので、ある程度処理したイベントの履歴は保持しておかないと冪等性は担保できない。
    - ローカルの変更とメッセージの処理状況の整合性は保つことが必要

# 集約
- 集約を利用するケース
  - とあるオブジェクトととあるオブジェクトで整合性を保ちたい場合に、それらを同じ集約に属するようにして不変な条件を保つことにより整合性を担保することができる。
- 巨大な集約を定義することによるデメリット
  - 例えばとある巨大な集約に対する変更を行う際に変更が完了されるまでその集約がロックされてしまうと、他にその集約に対して変更を行おうとするクライアントが変更を行えなくなってしまうことがある。またそれぞれで変更しようとしている箇所は互いに挙動に影響を及ぼさない場合は、変更が行えなくなるというのはシステムを使いにくくしてしまうので望ましくない。
- 小さな集約のメリット
  - 上記のようなデメリットから、集約はなるべく小さく定義したほうがよい。小さい集約を定義することにより、特定のオブジェクトの更新によって他のオブジェクトの更新が妨げられることはなくなる。
- 集約を定義するルール
  - 真の不変条件を整合性の境界内にモデリングする
    - 集約オブジェクトを定義した場合、そのオブジェクトのフィールドに不変条件を表すデータを保持させて都度チェックさせる
  - 小さな集約を設計する
    - 集約を「他の要素との整合性を保つ必要のあるもの」のみで構成する。(name と description の関係は name が変更されたらその name の説明文を表す description も変更される。)
  - 他の集約への参照にはその識別子を利用する
    - 他の集約と関連する場合は、その集約を自身の集約内に収めるということはせずに、集約の識別子を保持しておきそれを使用して他の集約を辿れるようにしておく。これにより集約の肥大化を防ぐ。
  - 境界の外部では結果整合性を用いる
    - 一つの集約でコマンドを実行する際に他の集約のコマンドも実行しなければならない、すなわち複数の集約に対してコマンドを実行する際には結果整合性を用いる。大抵の結果整合性で問題ないケースがほとんどである。結果整合性はドメインイベントを使用することで実現可能。
- ルールに違反する理由
  - 上記のルールにあえて違反するケースも存在する。ルール違反が妥当なケースは以下。
    - ユーザインターフェースの利便性
      - UI 的な利便性を考慮した結果集約を大きくしたくなった場合、それでもデータの整合性の観点から問題なければルールに違反しても良い
    - 技術的な仕組みの欠如
      - そもそもレガシーシステムで整合性を担保する方法が存在しない場合
    - グローバルなトランザクション
      - 二相コミット: 一旦コミットできるかを問い合わせて問題なければコミットする
    - クエリのパフォーマンス
      - オブジェクトの参照を保持することでパフォーマンスが向上する場合。ただし集約のサイズや全体的なパフォーマンスとトレードオフとなる。
- リポジトリ
    
