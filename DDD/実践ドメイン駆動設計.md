# 境界づけられたコンテキスト

- システムを構築する際にはドメインを関心ごとを基準に分割する必要がある。これは関心ごとが衝突していると修正の障害となるからためである。
- ソフトウェアが解決する領域のことをドメインと呼ぶ。その中でも、競合優位性が高いといったある観点で重要となってくるドメインのことをコアドメインと呼ぶ。これを優先してモデリングを行っていくことになる。
- 関心ごとに基づいて分割された個々のドメインのことをサブドメインと呼ぶ。大抵システムは複数のサブドメインから構成される。
- サブドメインの中でも業務ロジックではないが業務ロジックを実現するためのアルゴリズムなどがまとめられているサブドメインはモジュールとして扱う方が良い
- 各サブドメインは他のサブドメインと連携して一つのドメインを実現するが、サブドメインごとの連携方法にもさまざま存在する。これをコンテキストマップと呼ぶ。
- 自分たちで境界づけられたコンテキストを可視化してみるのもいい経験になる。

- 問題空間と解決空間
  - 問題空間とは新しいコアドメインを生み出すために開発を要するところ。既存のサブドメインに加えて、今後必要になるサブドメインも検討する必要がある
  - 解決空間とは境界づけられたコンテキストのことを指す。境界づけられたコンテキストは特定のソリューションをソフトウェアとして具現化したもの。
- ライフサイクル(境界づけられたコンテキスト)によって違ったモデリングとなる
  - 書籍の例
    - 書籍を出版する出版社の業務フローは大体以下のようなステップに分けられる
      - 書籍の内容を案としてまとめ、起案する
      - 著者と出版契約を結ぶ
      - 書籍の執筆と編集のプロセスを管理する
      - 書籍をデザインする
      - 書籍を他言語に翻訳する
      - 紙の書籍や電子版を作成する
      - 書籍を宣伝する
      - 書籍を再販業者に販売する
      - 紙の書籍を再販業者や顧客に出荷する
    - 各ステップで「書籍」の定義は異なるので、共通の書籍モデルを扱ってしまうと無理が生じるケースがほとんどである。したがって各ステップ(コンテキスト)ごとに書籍のモデリングを行うのが効果的である。各ステップ間で書籍の情報を共有したい場合は、書籍に識別子を持たせておいてそれをキーに各ステップで書籍のモデルを構築するような実装を行う(識別子は最初の起案ステップで発行し、以降それを各ステップで使用する)。
  - コンテキストのスコープ
    - データベーススキーマにドメインの概念が含まれる(カラム名がユビキタス言語で表されている etc...)場合は、そのDBも同じコンテキストに含まれる。そうでない場合はDBはコンテキストには含まれない
    - 同じく UI にドメインの概念が含まれる場合も UI もそのコンテキストに含まれる。しかし、UI は技術的な関心ごとがメインであることに加え、UI にドメインのロジックを含めるとドメインロジック貧血症を起こすことになったりドメインロジックの置き場所が散財するので望ましくない。
  - コンテキストの大きさ
    - ユビキタス言語の全てを表現できる範囲でのモデリングをすべきである。不要な概念やモデルは含めるべきではない
  - そのコンテキストで真に必要な概念は何かを検討し、もしそれにそぐわないモデルが存在する場合は別のモジュールやコンテキストに切り分ける必要がある。

# コンテキストマッピング
- あるドメインにおいて各コンテキスト間の関連を可視化することをコンテキストマッピングと呼ぶ。コンテキストマッピングを行う目的としては、各コンテキスト間の関連を可視化することで解決空間の全貌を俯瞰できるようにすることである。
- 2つのコンテキストの関連には以下のようなパターンが存在する
  - パートナーシップ
    - それぞれのコンテキストを担当するチームが共同して開発を進めるパターン
  - 共有カーネル
    - 2つのコンテキスト間で同じモデルを使用する。一方がモデルを修正する場合はもう一方の許可なくしては修正を行ってはならない(共有モデルの修正がもう一方の実装に影響を及ぼすため)。
  - 顧客/供給者の開発
    - 上流(供給者)が顧客(下流)の要望を聞いて開発を行うパターン。
  - 順応者
    - 上流が下流の要望を聞かないパターン。下流はただただ上流で行われた修正を取り込むのみ。
  - 腐敗防止層
    - 上流から提供されるオブジェクトモデルを自身のドメインの関心ごとに合致させるためにオブジェクトの変換を行う。
  - 公開ホストサービス
    - もう一方のコンテキストからアクセスできるように REST や メッセージングなどでサービスを公開する。
  - 公表された言語
    - 2つのコンテキストで定義されているモデルの変換を行えるように各モデルに変換可能な共通の言語を定義すること。公開ホストサービスと併用されるケースが多い。
  - 巨大な泥団子 -> 学ぶ意味なし
  - 別々の道 -> 学ぶ意味なし
- 単体のコンテキストの処理が関連する他のコンテキストの稼働状態に極力依存しないような実装にしたい場合
  - 関連するコンテキストのサービス状態が自分たちのコンテキストの処理の成否に影響を及ぼすような事態は極力避けたい。自立性を確保するためには、他のコンテキストから取得するような情報をローカルにキャッシュするのが一つの解決策となる。その場合、定期的に外部のコンテキストへのリクエストを実行し、取得した情報をもとに自分たちのモデルを更新するようなことを行えば良い。