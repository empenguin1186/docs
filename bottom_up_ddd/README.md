<!-- TOC -->

- [ボトムアップでわかる! ドメイン駆動設計入門](#ボトムアップでわかる-ドメイン駆動設計入門)
    - [Chapter 1 ドメイン駆動設計とは](#chapter-1-ドメイン駆動設計とは)
        - [ドメイン駆動設計とは](#ドメイン駆動設計とは)
        - [ドメイン駆動設計のメリット](#ドメイン駆動設計のメリット)
        - [なぜ今ドメイン駆動設計か](#なぜ今ドメイン駆動設計か)
    - [Chapter 2 システム固有の値を表現する「値オブジェクト」](#chapter-2-システム固有の値を表現する値オブジェクト)
        - [値オブジェクトとは](#値オブジェクトとは)
        - [値オブジェクトの特徴](#値オブジェクトの特徴)
        - [値オブジェクトを採用するメリット](#値オブジェクトを採用するメリット)
        - [値オブジェクトを使用するケース](#値オブジェクトを使用するケース)
    - [Chapter 3 ライフサイクルのあるオブジェクト「エンティティ」](#chapter-3-ライフサイクルのあるオブジェクトエンティティ)
        - [エンティティとは](#エンティティとは)
        - [エンティティの特徴](#エンティティの特徴)
    - [Chapter 4 不自然さを解決する「ドメインサービス」](#chapter-4-不自然さを解決するドメインサービス)
        - [ドメインサービスとは](#ドメインサービスとは)
        - [ドメインサービスを使用するケース](#ドメインサービスを使用するケース)
    - [Chapter 5 データにまつわる処理を分離する「リポジトリ」](#chapter-5-データにまつわる処理を分離するリポジトリ)
        - [リポジトリとは](#リポジトリとは)
        - [リポジトリの責務](#リポジトリの責務)
        - [リポジトリの実装方針](#リポジトリの実装方針)
        - [リポジトリを使用するメリット](#リポジトリを使用するメリット)
    - [Chapter 6 ユースケースを実現する「アプリケーションサービス」](#chapter-6-ユースケースを実現するアプリケーションサービス)
        - [アプリケーションサービスとは](#アプリケーションサービスとは)
        - [アプリケーションサービスを実装するにあたっての注意事項](#アプリケーションサービスを実装するにあたっての注意事項)
    - [Chapter 9 複雑な処理を行う「ファクトリ」](#chapter-9-複雑な処理を行うファクトリ)
        - [ファクトリとは](#ファクトリとは)
        - [ファクトリを使用するケース](#ファクトリを使用するケース)
    - [Chapter 11 アプリケーションを1から組み立てる](#chapter-11-アプリケーションを1から組み立てる)
    - [Chapter 12 ドメインのルールを守る「集約」](#chapter-12-ドメインのルールを守る集約)
        - [集約とは](#集約とは)
        - [集約の特徴](#集約の特徴)
        - [集約の区切り方](#集約の区切り方)
    - [Chapter 13 複雑な条件を表現する「仕様」](#chapter-13-複雑な条件を表現する仕様)
        - [仕様とは](#仕様とは)
        - [仕様の実装内容](#仕様の実装内容)
        - [仕様を使用するケース](#仕様を使用するケース)
    - [Chapter 14 アーキテクチャ](#chapter-14-アーキテクチャ)
        - [アーキテクチャの役目](#アーキテクチャの役目)
        - [代表的なアーキテクチャ](#代表的なアーキテクチャ)
            - [レイヤードアーキテクチャ](#レイヤードアーキテクチャ)
            - [ヘキサゴナルアーキテクチャ](#ヘキサゴナルアーキテクチャ)
            - [クリーンアーキテクチャ](#クリーンアーキテクチャ)
- [社内向け発表のメモ](#社内向け発表のメモ)
    - [ドメイン駆動設計とは](#ドメイン駆動設計とは-1)
        - [ドメイン駆動設計とは何か](#ドメイン駆動設計とは何か)
        - [ドメインの知識に焦点を当てた設計手法](#ドメインの知識に焦点を当てた設計手法)
            - [ドメインとは](#ドメインとは)
            - [ドメインの知識に焦点を当てる](#ドメインの知識に焦点を当てる)
            - [ドメインモデル](#ドメインモデル)
            - [知識をコードで表現するドメインオブジェクト](#知識をコードで表現するドメインオブジェクト)
        - [ドメイン駆動設計における実装パターン](#ドメイン駆動設計における実装パターン)
            - [知識を表現するパターン](#知識を表現するパターン)
            - [アプリケーションを実現するためのパターン](#アプリケーションを実現するためのパターン)
            - [知識を表現する、より発展的なパターン](#知識を表現するより発展的なパターン)
    - [値オブジェクト](#値オブジェクト)
        - [値オブジェクトとは](#値オブジェクトとは-1)
        - [値の性質と値オブジェクトの実装](#値の性質と値オブジェクトの実装)
            - [不変である](#不変である)
            - [交換が可能である](#交換が可能である)
            - [等価性によって比較される](#等価性によって比較される)
        - [値オブジェクトにする基準](#値オブジェクトにする基準)
        - [振る舞いを持った値オブジェクト](#振る舞いを持った値オブジェクト)
        - [値オブジェクトを採用するモチベーション](#値オブジェクトを採用するモチベーション)
            - [表現力を増す](#表現力を増す)
            - [不正な値を存在させない](#不正な値を存在させない)
            - [誤った代入を防ぐ](#誤った代入を防ぐ)
            - [ロジックの散在を防ぐ](#ロジックの散在を防ぐ)
        - [まとめ](#まとめ)

<!-- /TOC -->

# ボトムアップでわかる! ドメイン駆動設計入門

## Chapter 1 ドメイン駆動設計とは
- 以下の事項について説明できるようになることをゴールとする
  - ドメイン駆動設計とは
  - ドメイン駆動設計のメリット
  - なぜ今ドメイン駆動設計か

### ドメイン駆動設計とは
- ドメインの知識に焦点を当てた設計手法のことを指す。ここでいうドメインとは、プログラムを適用する対象領域のことを指す。例えば会計システムであれば帳票や金銭、配送システムでは倉庫や配送手段などがドメインに含まれる。ソフトウェアはユーザの課題を解消するために存在するので、その目的を果たすために役立つ知識や概念をドメインに含めて開発を行う必要がある。

### ドメイン駆動設計のメリット
- 汎用的なソフトウェアの設計のパターンを身に付けることができるので、設計段階で理想を現実に適合する場合に取るべき選択肢を増やしてくれる。
- ドメイン駆動設計によって開発されたソフトウェアは変更容易性が高くなる。

### なぜ今ドメイン駆動設計か
- ドメイン駆動設計が提唱されたのは2003年ごろと歴史があるものとなっているが、一昔前のソフトウェア開発はいち早く開発を完了しリリースすることが最も重要であると考えられていた。そのような背景から開発初期段階にモデリングに時間をかけるドメイン駆動設計は選択肢には入らなかった。しかし、速度を重視した開発は柔軟性や変更容易性が低いソフトウェアを生み出し、開発が進むにつれて場当たり的な修正を行う羽目になった。やがて開発者たちは速度よりも変更容易性の高いソフトウェアを開発することを望むようになり、結果としてドメイン駆動設計が注目されるようになった。

## Chapter 2 システム固有の値を表現する「値オブジェクト」
- 以下の事項について説明できるようになることをゴールとする
  - 値オブジェクトとは
  - 値オブジェクトの特徴
  - 値オブジェクトを採用するメリット
  - 値オブジェクトを使用するケース

### 値オブジェクトとは
システム固有の値を表したオブジェクトのことを指す。例えば、姓と名で構成される FullName を考えたときに、名前なのでプリミティブな String 型でも表現することができるが、FullNameクラスを定義することによって姓名それぞれを特定することが容易となって汎用性が高くなる。

### 値オブジェクトの特徴
- 値が不変
- 交換(代入)が可能である
  - 値オブジェクトの内部の値は不変だが、値オブジェクト自体は代入することができる。
- 等価性によって比較される
  - 同一性ではなく、等価性によって比較される。そのためには、比較用のメソッドを実装する必要がある。
- 属性が追加されても修正不要
  - 値オブジェクトに関する判定処理を値オブジェクト自身で実装することにより、変更箇所を最小限に留めることができる。

### 値オブジェクトを採用するメリット
- 表現力を増す
  - 単なるプリミティブ型で値を表現するより、ルールが表現されている値オブジェクトを使用した方が、どのような処理を行なっているのか、メソッドやコンストラクタの場合引数にどのようなものが渡されているのかが理解しやすくなる。
- 不正な値を存在させない
  - 「ユーザ名はN文字以上」といったルールをコンストラクタに組み込むことで、不正な値が入力されたことによる異常事態をいち早く気づくことができる。
- 誤った代入を防ぐ
  - 型を定義することにより、誤った代入が行われるのを防ぐ。例えば、本来ならユーザ名を代入するところをパスワードを代入したしまったケースなど。
- ロジックの散在を防ぐ
  - 値オブジェクトに関するロジックは値オブジェクトで定義した方が、ロジックがもし変更された場合でもクライアントのコードの変更は行わなくてもよくなるので、変更容易性が高いコードを作成することができる。

### 値オブジェクトを使用するケース
- まず、どの概念を値オブジェクトで表現するかだが、基準として何かの業務ルールが存在する場合は値オブジェクトの作成を検討する。例えば、パスワードを設定する際に文字数の制限や使用できる文字の種類が決まっている場合はパスワードを単なるプリミティブ型で表現するのではなく、値オブジェクトとして表現した方が良い。

## Chapter 3 ライフサイクルのあるオブジェクト「エンティティ」
- 以下の事項について説明できるようになることをゴールとする
  - エンティティとは
  - エンティティの特徴

### エンティティとは
- エンティティとは、同一性で区別されるオブジェクトのことを指す。例えば、システムのユーザの多くは自身でユーザの情報を変更することができるが、情報を変更したからといってユーザ自身が変更後別のユーザになるということはない。こういったオブジェクトのことをエンティティと呼ぶ。

### エンティティの特徴
- 可変である
  - 値オブジェクトと異なり、エンティティは可変の要素をもつ(ユーザの身長など)場合が存在する
- 同じ属性であっても区別される
  - 姓名は属性であり、同姓同名の人間が同じ人間かと言われると違うように、エンティティも属性が同じだからとはいえ同じものだと区別はされない。
- 同一性により区別される
  - ユーザ情報を変更したからといって変更前と変更後は違うユーザとなるということはない。これはユーザは同一性の検証によって同じユーザであると判定されているためである。したがってエンティティの同一性を検証する方法が必要だが、大抵はIDなどを元に同一性を検証することとなる。

## Chapter 4 不自然さを解決する「ドメインサービス」
- 以下の事項について説明できるようになることをゴールとする
  - ドメインサービスとは
  - ドメインサービスを使用するケース

### ドメインサービスとは
- ドメインサービスとは、値オブジェクトやエンティティで実装するには直感的でなくきまりが悪いロジックを実装するクラスのことを指す。例えば、そのユーザ名が既に存在しているかどうかの検証メソッドを実装する場合、エンティティ自身にこのロジックを実装させるのはいささか違和感が伴う。ここでドメインサービスでこの検証処理を実装すれば不自然さを解消することができる。

### ドメインサービスを使用するケース
- まず、なんでもかんでもドメインサービスにロジックを実装すべきではない。値オブジェクトやエンティティの表現力が低下するからである。これをドメインモデル貧血症と呼ぶ。可能な限りドメインサービスでロジックを実装することは避け、どうしてもロジックが値オブジェクトやエンティティの責務ではない場合にのみ実装する。

## Chapter 5 データにまつわる処理を分離する「リポジトリ」
- 以下の事項について説明できるようになることをゴールとする
  - リポジトリとは
  - リポジトリの責務
  - リポジトリの実装方針
  - リポジトリを使用するメリット

### リポジトリとは
- リポジトリは、データストアなどを使用してデータの永続化や再構築を行うためのオブジェクトのことをさす。

### リポジトリの責務
- リポジトリはデータの永続化や再構築を行うオブジェクトなので、ドメインロジックはリポジトリでは実装すべきではない。ドメインオブジェクトはあくまでドメインサービスや値オブジェクト、エンティティで実装する。

### リポジトリの実装方針
- リポジトリは基本的にはインターフェースを切って実装を行う

### リポジトリを使用するメリット
- データストアへの接続やSQLの発行をリポジトリで実装することにより、ドメインサービスではそれらの処理を気にせずにロジックを組み立てることができる
- テストを実行する場合はテスト用のリポジトリを定義することによって実際にデータストアを使用することなくテストを実行することができる。

## Chapter 6 ユースケースを実現する「アプリケーションサービス」
- 以下の事項について説明できるようになることをゴールとする
  - アプリケーションサービスとは
  - アプリケーションサービスを実装するにあたっての注意事項
  - アプリケーションサービスを使用するケース

### アプリケーションサービスとは
- ドメインサービスとは異なり、ドメインオブジェクトを組み合わせてシステムを利用するユーザが取りうるアクション(サービス利用開始、基本情報変更、退会 etc...)を体現するのがアプリケーションサービスである。

### アプリケーションサービスを実装するにあたっての注意事項
- アプリケーションサービスでクライアントにドメインオブジェクトをそのまま渡すのは避けるべきである。なぜならドメインオブジェクトを渡すとクライアント側でもドメインロジックを実行することができてしまい、ドメインロジックを実行するという責務をあらゆる層が持つことになるからである。これを避けるためにアプリケーションサービスはドメインオブジェクトではなく Data Transfer Object (DTO)を渡すことがあげられる。
- アプリケーションサービスではドメインロジックを実装するべきではない。あくまでアプリケーションサービスはドメインオブジェクトやそのメソッドを呼び出すにとどめておく。例えば、ユーザの検索処理はアプリケーションサービスで実装すると、検索処理自体のロジックを変更する場合にはそれぞれ使用している箇所を全て修正しなければならないが、ドメインサービスで実装すればアプリケーションサービスはその修正したメソッドを呼び出すだけで機能を修正できる。
- アプリケーションサービスはなるべく凝集度を高くすることが重要である。凝集度をはかる指標としてLCOMというものが存在し、これはクラスのフィールドがどのメソッドで使用されているかを測る物である。
- アプリケーションサービスをインターフェースとして定義すると、クライアントはそのインターフェースを使用することにより、実装完了を待たずしてクライアント側の処理を実装できる。

## Chapter 9 複雑な処理を行う「ファクトリ」
- 以下の事項について説明できるようになることをゴールとする
  - ファクトリとは
  - ファクトリを使用するケース

### ファクトリとは
- 複雑なオブジェクトの生成処理を定義したオブジェクトのことを向上となぞらえてファクトリと呼ぶ。ファクトリを定義することにより、クライアントはオブジェクトを生成するに至るまでの複雑な処理の過程を知ることなく目的のオブジェクトを生成することができる

### ファクトリを使用するケース
- インスタンスを生成するという観点から、ファクトリはコンストラクタと責務が同じであると捉えることができるが、コンストラクタとの使い分けに関しては、コンストラクタはインスタンスの生成が比較的単純な場合に使用する。コンストラクタの中で別のオブジェクトを生成するようなことがあった場合、そのオブジェクトが変更されたらコンストラクタも変更する恐れがあるのでこういった場合はファクトリで実装した方が良い。

## Chapter 11 アプリケーションを1から組み立てる
- アプリケーションを作成するフローについて説明できるようにする
- デモンストレーションを通して気づいた点をまとめる

## Chapter 12 ドメインのルールを守る「集約」
- 以下の事項について説明できるようになることをゴールとする
  - 集約とは
  - 集約の特徴
  - 集約の区切り方
  - 集約を使用するケース

### 集約とは
- オブジェクトの不変条件を適用する単位。集約を定義することにより、オブジェクトに秩序をもたらす。例えば、以下のように Circle の名前を変更する擬似コードを考える

```kt
val circle = Circle()
circle.name = "CircleA"  // 1.
circle.changeName("CircleA")  // 2.
```
1. より2. が優れている点としては、メソッドで切り出したことにより不変条件(名前が〇〇文字以上になっているかどうか、null が指定されていないか)の判定を行うことができるところにある。ここで変更を命令を問い合わせる対象である circle のことを集約ルートと呼ぶ。また、Circle には name の他に、member, equipment などのプロパティも存在することが考えられる。こういった集約内に存在する要素のことを境界と呼ぶ。

### 集約の特徴
- 不変条件を適用する一つの単位である
- オブジェクトに変更を加える場合は集約ルートに対して問い合わせるしかないので、むやみやたらに外部から状態を変更されることを防ぐことができる

### 集約の区切り方
- ある集約から異なる集約の要素を変更するような実装は避ける。
- 集約はできるだけ小さく保つ。複数のトランザクションを張る場合はそれ全体を集約として扱わない方が良い。

## Chapter 13 複雑な条件を表現する「仕様」
- 以下の事項について説明できるようになることをゴールとする
  - 仕様とは
  - 仕様の実装内容
  - 仕様を使用するケース

### 仕様とは
- アプリケーションを作成するにあたりオブジェクトに対する判定ロジックを実装するのはよくあることである。単純なロジックはそのオブジェクトに実装すれば良いが、複雑な判定ロジックを実装する場合には、仕様に基づいて判定を行うオブジェクトを別途定義し判定を行わせるのも一つの手である。
- 例えば User のタイプに応じて Circle の人数の上限を変更するケースを考える。ここで Circle オブジェクトが集約の観点から User そのものではなく UserId を内部で保持している場合、上限を判定するロジックを Circle オブジェクトで実装する場合、 Repository クラスをメソッドに渡して上げる必要がある。しかし、ドメインオブジェクトである Circle に本来DDDの概念ではない Repository を追加することは望ましくない。したがって Circle オブジェクトと Repository を受け取って上限を判定する仕様オブジェクトを作成するのが望ましい。また、Repositoryを渡さずともアプリケーションサービスで Repository からUserを取得し、そのリストを渡してあげることでも実現可能である。この場合仕様もドメインオブジェクトのみで構成されるので一貫性を保つことができる

### 仕様の実装内容
- 仕様の適用をアプリケーションサービスで行うか、Repository に仕様インターフェースを渡して判定を行うかの２択が存在する。

### 仕様を使用するケース
- あるリストに対して何かフィルタリングを行うような場合に有効な考え方の一つである。

## Chapter 14 アーキテクチャ
- 以下の事項について説明できるようになることをゴールとする
  - アーキテクチャの役目
  - 代表的なアーキテクチャ
    - レイヤードアーキテクチャ
    - ヘキサゴナルアーキテクチャ
    - クリーンアーキテクチャ

### アーキテクチャの役目
- ECサイトを例にあげて説明すると、ECサイトで注文詳細、履歴、購入確定画面で合計金額を表示する場合、各画面で合計金額を計算するロジックを実装していると、計算ロジックに変更が発生した場合には全ての画面のロジックの変更を余儀なくされ、修正コストが高くなる。したがってUIには極力ロジックを持たせない方が良い。ロジックを持ったUIを「利口なUI」と呼ぶ。こういったケースの解決策としては、サーバ側で計算ロジックを実装し、UIはその結果を受け取って表示するだけに止めることである。
- 上記のUIの例でもあるように、ロジックを適切な箇所に実装することはソフトウェアを開発する際には重要である。そのロジックをどこに実装するかの指針を示しているのがアーキテクチャと呼ばれるものである。

### 代表的なアーキテクチャ
#### レイヤードアーキテクチャ
- プレゼンテーション層、アプリケーション層、ドメイン層、インフラストラクチャ層で構成されるアーキテクチャ。プレゼンテーション -> アプリケーション -> ドメイン -> インフラストラクチャ という依存の矢印をもち、下位層は上位層に依存してはならない。

#### ヘキサゴナルアーキテクチャ
- 入力と出力の実装に依存せずにドメインロジックを守るように設計されたアーキテクチャ。入力と出力にはそれぞれアダプタとポートが存在し、それぞれアダプタがクライアント、ポートが実行するメソッドのことを指す。アダプタがポートに必要なの引数のインスタンスを生成し、ポートが実際にそれを用いて処理を実行する。ポートはインターフェースで定義されているため、入力と出力の汎化を実現している。

#### クリーンアーキテクチャ
- クリーンアーキテクチャはヘキサゴナルアーキテクチャと似ているが、ヘキサゴナルと異なる点として具体的な実装方針が述べられている点である。Controller -> Use Case Input Port(I) <|- Use Case Interactor -> Use Case Output Port(I) <|- Presenter といった依存、汎化関係が存在し、処理のフローは Controller -> Use Case Interactor -> Presenter の順となる。Controller は User Case は Use Case Input Port 越しに Interactor を呼び出すので、スタブを用意することでテストを容易に実行することができる。また Use Case Interactor も Use Case Output Port 越しに Presenter を呼び出すので、同様にテスト容易性を高めることができる。このようにドメインロジックを隔離できるのがクリーンアーキテクチャの利点である。


# 社内向け発表のメモ

## ドメイン駆動設計とは

### ドメイン駆動設計とは何か
- 我々がユーザにとって役立つソフトウェアを開発するためには、まずそのソフトウェアの利用者の課題や取り巻く世界について学ぶ必要がある。物流システムを構築する際には物流に関する知識を、会計システムを構築するには金融の知識を学ぶ必要があるだろう。しかし、その世界には様々な知識が存在し、どの知識がソフトウェア開発に役立つかは取捨選択をしなければならない。例えば物流システムにおいてはトラックの積載量や輸送ルートといった知識は物流システムにおいて利用価値が高いものだと言えるが、トラックの語源がラテン語の「trochus」で、その意味が「鉄の輪」であるという知識は利用価値は低いものであることが判断できるだろう。このようにソフトウェア開発においてはその取り巻く世界に関する知識を有効かどうかを取捨選択し、有効であると判断された知識をコードに落とし込んでいくことが必要となる。ドメイン駆動開発はユーザのニーズから必要な知識が何であるかの洞察を繰り返し、実装に結びつけることを目的としている。

### ドメインの知識に焦点を当てた設計手法

#### ドメインとは
- ドメインは「領域」の意味を持った言葉であり、ソフトウェア開発におけるドメインは「プログラムを適用する対象となる領域」を指す。したがって開発するソフトウェアによってドメインはそれぞれ異なる。例えば、物流システムに関しては貨物や倉庫、輸送手段などの概念がドメインに含まれ、会計システムでは金銭や帳票といった概念がドメインに含まれる。

#### ドメインの知識に焦点を当てる
- ソフトウェアには必ずユーザが存在する。より良いソフトウェアを開発するためにはそのユーザが抱えている課題やニーズを正確に理解することが必要である。ユーザがどんな課題を解決したいと思っているのか、どのようなニーズを持っているのかを知るためには、ユーザの視点や考え、取り巻く環境を理解する必要がある。したがってドメインと向き合うことが必要となる。
- ドメインの概念や事象を理解し、その中から課題解決に役立つものを抽出して得られた知識をソフトウェアに反映するという作業は当たり前の行為である。しかし、技術指向の開発者であればあるほどこの工程をおろそかにしがちである。最新のフレームワークや開発手法にばかり目がいってしまい、ドメインを向き合わずにソフトウェアを開発していくと結果ユーザのニーズとは的外れのソフトウェアが出来上がってしまうなんていうこともあり得る。したがってこのような事態を招かないようにするためにも、ソフトウェアに適用する範囲をしっかりと把握し、関係する知識に焦点を当てる必要がある。

#### ドメインモデル
- 「ドメインモデル駆動設計とは何か」の項で、ドメインに含める知識は取捨選択する必要があるということを述べたが、そうやって現実の事象や概念をある程度抽象化したものをドメインモデルと呼ぶ。ドメインモデルは現実世界をそのまま表現するということはしない。例えば、ペンについて考えてみると、小説家にとってペンは文字を書けるという特性が一番重要なので、その性質がドメインモデルに反映されることになるが、文房具店にとってはペンは商品の一部なので、在庫やその値段といった性質が重要となる。したがってそれらがドメインモデルに反映されることになる。このことから、ドメインモデルに反映されるものはコンテキストによって異なるということである。
- 現実世界は複雑なので、ドメインモデルを構築する場合に現実世界の知識を忠実に再現するのは不可能であるし再現する必要もない。ソフトウェア開発に役立つ知識のみピックアップして表現することができればそれで十分だし、実装も現実的なものになる。こういったモデルを構築する知識を取捨する行為をモデリングと呼ぶ。

#### 知識をコードで表現するドメインオブジェクト
- ドメインモデルをコードで表現したものをドメインオブジェクトと呼ぶ。ドメインで起こった変化はドメインモデルに伝わり、そのコード表現であるドメインオブジェクトにまで反映されることになる。逆にドメインで起こった変化がドメインオブジェクトで表現することが難しいと判断された場合は、ドメインで起こった変化を見直すというアクションが取られる。このようにドメインとドメインオブジェクトは相互に影響し合う関係性にある。

### ドメイン駆動設計における実装パターン
- ドメイン駆動設計には様々な概念が登場する。混乱を避けるために大まかにグルーピングして説明していく

#### 知識を表現するパターン
- 最初にドメインに含まれる知識を表現するパターンについて説明する。具体的に説明するパターンは以下のオブジェクト。
  - 値オブジェクト
    - ドメイン固有の概念を値として表現するオブジェクト。
  - エンティティ
    - ドメイン固有の概念を表現するという意味では値オブジェクトと同じであるが、値オブジェクトと対をなす性質をもつオブジェクト。
  - ドメインサービス
    - 値オブジェクトやエンティティでは表現できない知識を取り扱うためオブジェクト。

#### アプリケーションを実現するためのパターン
- ドメインに含まれる知識を表現しただけではソフトウェアの要件を満たしていない。そこでソフトウェアの要件を満たすために必要なパターンについて説明する。
  - リポジトリ
    - データの保存や復元といった永続化や再構築を再現するオブジェクト。外部のデータストアに対する操作を抽象化することでソフトウェアに柔軟性を持たせる。
  - アプリケーションサービス
    - 値オブジェクト、エンティティ、ドメインサービス、リポジトリをうまく強調させてアプリケーションとしての機能を表現するオブジェクト。
  - ファクトリ
    - 生成が複雑であるオブジェクトの生成を担当するファクトリ。ファクトリを使用するオブジェクトにとってはその生成処理を隠蔽することでオブジェクトの使用を容易にする。また、生成処理をファクトリに集中させることで処理の目的を明確にするという役割もある。

#### 知識を表現する、より発展的なパターン
- 知識を表現するより発展的なパターンについてのべる。
  - 集約
    - 整合性を保つ境界をさす。値オブジェクトやエンティティを複合してより複雑なドメインの概念を表現する。
  - 仕様
    - オブジェクトの評価をモジュール化したもの

## 値オブジェクト

### 値オブジェクトとは

- 値オブジェクトがなんであるかを理解してもらうため、名前をコードでどのように表現するかを考えてみる。一番簡単な方法は以下のように String クラスで定義することが考えられるだろう。
```java
String fullName = "Yahoo Taro";
```

- この fullName はそのまま使用されることもあるし、姓だけ使用する場合も考えられるだろう。そうなった場合には以下のような処理を実装する必要がある。
```java
String[] tokens = full.split( " ");
String lastName = tokens[0];  // Yahoo
String firstName = tokens[1]; // Taro
```

- 一見これは正しい実装に見えるが、場合によっては間違った実装となる。以下のようなケースである。
```java
String fullName = "John Smith";
String[] tokens = full.split( " ");
String lastName = tokens[0]; // John
String firstName = tokens[1]; // Smith
```

- 現実世界には先頭に名が来るケースが存在するので上記のような実装は場合によっては不具合が生じてしまう。これを避けるためにクラスを利用するパターンが存在する。
```java
class FullName {

  private String firstName;
  private String lastName;

  public FullName(String firstName, String lastName) {
      this.firstName = firstName;
      this.lastName = lastName;
  }

  public String getFirstname() {
      return firstName;
  }

  public String getLastname() {
      return lastName;
  }
}
```
- この例からわかるのは、システムに最適な値が必ずしもプリミティブな値であるとは限らないということである。このようにシステム固有の値を表したオブジェクトを値オブジェクトと呼ぶ。

### 値の性質と値オブジェクトの実装
- 値の性質について取り上げながら値オブジェクトの特徴について説明する。主な特徴については以下の3つ。
  - 不変である
  - 交換が可能である
  - 等価性によって比較される

#### 不変である
- 値の性質に不変というものがある。以下のコードを考える。
```java
1 = 0; // 値の変更(擬似コード)

if (1 == 0) {
  System.out.println("num is 0")
}
```
- 値の変更が可能であると仮定するれば、上記のコードを実行した場合、「num is 0」という出力結果が得られるだろう。しかしご存知の通りこのコードはコンパイルエラーとなり、プログラムとしての要件を満たしていない。1はどこまでいっても1という値をとり、0はどこまでいっても0という値をとる必要がある。すなわち不変である必要がある。でなければ安全に値を使用することができない。
- この性質にならい値オブジェクトも不変にするのが望ましい。不変にすることで、プログラムの途中で値が変更されるという事態がなくなり、予期せぬバグを防ぐことができる。

#### 交換が可能である
- 値は不変である必要があるということを前項で述べたが、値を変更せずにソフトウェアを開発することは難しい。なんらかの処理に応じて値を変更するなんてケースは必ず発生するだろう。その場合は値の変更ではなく交換することで目的を達成できる。

```java
FullName fullName = new FullName("Yahoo", "Taro");
fullName = new FullName("Smith", "John");
```
- 値そのものを変更するのではなく、異なる値を用意して交換を行うことで変更を行わずしてオブジェクトの状態を変更することができる。

#### 等価性によって比較される
- 値同士の比較を行う場合、結果は以下のようになる
```java
0 == 0 // true
1 == 0 // false
'a' == 'a' // true
'b' == 'b' // false
"hello" == "hello" // true
"hello" == "こんにちは" // false
```
- この例からわかることは、値に関しては別のインスタンスであっても、属性が一致していれば等価であると判断される(同一性は気にしない)。値オブジェクトもインスタンスが同一かどうかではなく、属性によって等価性が判断される。
- また、値オブジェクトは値オブジェクトそのものを比較するメソッドを実装する方が自然な記述となる。以下が実装例となる。
```java
class FullName {

  private String firstName;
  private String lastName;
  
  ...

  @Override
  public boolean equals(Object obj) {
      FullName other = (FullName) obj;
      return this.firstName.equals(other.getFirstname()) && this.lastName.equals(other.getLastname());
  }

  @Override
  public int hashCode() {
      int result = this.firstName.hashCode();
      result = 31 * result + this.lastName.hashCode();
      return result;
  }
}
```

- この実装によって以下のような値オブジェクト同士の比較が可能となる。
```java
FullName a = new FullName("Yahoo", "Taro");
FullName b = new FullName("John", "Smith");

if (a.equals(b)) {
  ...
}
```
- 等価性を判断するメソッドを実装するメリットは記述の自然さをもたらすことだけではない。例えばFullNameクラスに middleName というフィールドを追加することになり、それに伴いequalsメソッドを改修しなければならない場合、以下のように FullName クラスの equals メソッドのみを改修するだけで良い。

```java
class FullName {
  private String firstName;
  private String middleName
  private String lastName;
  
  @Override
  public boolean equals(Object obj) {
      FullName other = (FullName) obj;
      return this.firstName.equals(other.getFirstname()) && this.middleName.eqals(other.getMiddleName()) && this.lastName.equals(other.getLastname());
  }
}
```
- 一方以下のように FullName クラスを使用する側で判断のメソッドを実装している場合は、各使用箇所で修正を行う必要があり、場合によっては手間がかかる場合がある。このようにロジックを集中させることで無駄な修正を減らすことができるのも値オブジェクトを実装するメリットである。

```java
if (a.getFirstName().equals(b.getFirstName()) && a.getMiddleName().equals(b.getMiddleName()) && a.getLastName().equals(b.getLastName())) {
  ...
}
```

### 値オブジェクトにする基準
- どのような概念を値オブジェクトとして実装すればいいのかという判断は、「そこにルールが存在しているか」という点と「それ単体で扱いたいか」という観点で考えるとよい。例えば FullName クラスは姓と名で構成され、かつ単体で使用したいので値オブジェクトとして取り扱うのが望ましいだろう。またこの場合に firstName と lastName は現状システム的なルールは存在しない。これに文字数制限や文字種制限などが課せられた場合は値オブジェクトにすることを検討した方が良い。

### 振る舞いを持った値オブジェクト

- 値オブジェクトの重要な特性として、独自の振る舞いを定義できることが挙げられる。ここでお金に関するオブジェクトについて考える。お金には金額と通貨単位(円、ドル etc...)の2つの属性がある。これを値オブジェクトとして定義すると以下のようになる。
```java
class Money {
  private int amount;
  private Currency currency;

  public int getAmount() {
      return amount;
  }

  public Currency getCurrency() {
      return currency;
  }

  public Money(int amount, Currency currency) {
      if (currency == null) throw new IllegalArgumentException("通貨単位が null です。");
      this.amount = amount;
      this.currency = currency;
  }

  public Money add(Money arg) {
      if (arg == null) throw new IllegalArgumentException("加算対象が null です。");
      if (arg.getCurrency().equals(this.currency)) throw new IllegalArgumentException("通貨単位が異なります。");
      
      return new Money(this.amount + arg.getAmount(), this.currency);
  }
}

enum Currency {
    JPY,
    USD
}
```
- add メソッドはお金同士の加算を行うメソッドである。加算を行う際に異なる通貨単位のお金を加算しようとしたら例外がスローされるような実装となっている。この実装によるメリットは、このお金オブジェクトの使用者が誤って異なる通貨単位のお金を加算しようとした場合には即座に間違いに気づけるという点である。このように、値オブジェクト自体にドメインの知識に基づくルールを定義しておくことで、間違った操作による不具合を防ぐことができる。

### 値オブジェクトを採用するモチベーション
- 値オブジェクトを定義するとなると、当然のように多くのクラスを定義しなければならなくなり、煩雑であると感じることもあるだろう。そういった心理的ハードルを乗り越えてまで値オブジェクトを定義する必要があるのか疑問に感じることもあると思う。したがってこの項では値オブジェクトを採用するモチベーションについてのべる。値オブジェクトを採用するモチベーションとしては以下の4点が挙げられる。順を追って説明していく。
  - 表現力を増す
  - 不正な値を存在させない
  - 誤った代入を防ぐ
  - ロジックの散在を防ぐ

#### 表現力を増す

- 工業製品を例にとって説明しよう。工業製品にはロット番号やシリアル番号、製品番号など識別するための様々な番号が存在している。それらは数字だけで構成されることもあれば、アルファベットも含めた文字列で表されることもある。製品番号をプリミティブな値で表現するのなら、以下のような定義になるだろう。
```java
String modelNumber = "a20421-100-1";
```

- このように明確に変数宣言がされている場合は製品番号がどのようなフォーマットであるかを把握することはできる。しかし、以下のようにいきなりプログラムに出現した場合はどのようなフォーマットをしているのかはプログラムを遡ったりデバッグをしない限り把握するのは難しいだろう。
```java
void doSomething(String modelNumber) {
  ...
}
```

- 一方値オブジェクトを用いて製品番号を表現する場合は以下のようになる。
```java
class ModelNumber {
  private String productCode;
  private String branch;
  private String lot;

  public ModelNumber(String productCode, String branch, String lot) {
      if (productCode == null) throw new IllegalArgumentException("productCode が null です。");
      if (branch == null) throw new IllegalArgumentException("branch が null です。");
      if (lot == null) throw new IllegalArgumentException("lot が null です。");

      this.productCode = productCode;
      this.branch = branch;
      this.lot = lot;
  }

  @Override
  public String toString() {
      return this.productCode + "-" + this.branch + "-" + this.lot;
  }
}
```
- 値オブジェクトとして定義すると、製品番号はプロダクトコード(productCode)と枝番(branch)とロット番号(lot)から構成されることがコードから把握することができる。このように、値オブジェクトはその定義により自身がどういったオブジェクトであるかという自己文書化を推し進める。

#### 不正な値を存在させない
- ユーザ名を例にとって説明しよう。ユーザ名には大体「M文字以上N文字以下」、「利用できる文字はアルファベットと数字のみ」といったルールが存在する。例えば「ユーザ名は3文字以上」というルールがあったとして、以下のようなユーザ名はシステム的には異常な値である。
```java
String userName = "me"
```

- しかし、これはシステム的にはルールに違反しているが、プログラムとしてはとりうる値なので実行したところで何も問題なく動作する。したがって不正が値が混入したまま処理が行われることなり、結果的にシステム不具合が生じてしまう。一度このような異常な値の混入を許してしまうと、システム側で逐一以下のような値チェックを行う必要が出てくる。
```java
if (userName.length() >= 3) {
  // 正常な値なので処理を続行する
} else {
  throw new Exception("不正な値です。");
}
```

- しかし、このような値のチェックを行う箇所が複数になってくると、修正漏れが一つでもあった場合には再び異常な値の混入を許してしまう。そこで、以下のように値オブジェクトを利用することで異常な値の混入を防ぐことができる。
```java
class UserName {
  private String value;

  public UserName(String value) {
      if (value == null) throw new IllegalArgumentException("ユーザ名 が null です。");
      if (value.length() < 3) throw new IllegalArgumentException("ユーザ名は3文字以上でなければなりません。");
      
      this.value = value;
  }
}
```

- コンストラクタのガード節により UserName の生成に成功した段階で3文字以上のユーザ名のみ処理対象になることが担保され、システムで不具合が発生することを防ぐことができる。

#### 誤った代入を防ぐ

- あるシステムのユーザのオブジェクトを例にとって考える。ユーザはユーザIDとメールアドレスという属性を持っているとする。それぞれをプリミティブな値で定義した User クラスは以下のようになる。
```java
class User {
  private String userId;
  private String mailAddress;

  public User(String userId, String mailAddress) {
      if (userId == null) throw new IllegalArgumentException("UserId が null です。");
      if (mailAddress == null) throw new IllegalArgumentException("MailAddress が null です。");

      this.userId = userId;
      this.mailAddress = mailAddress;
  }
}
```

- このクラスのインスタンスを生成する場合は以下のようなコードを記述することになるだろう。
```java
User user = new User("hoge", "hoge@fuga.co.jp");
```

- ここで問題となるのは、userId フィールドも mailAddress フィールドも String で定義されているため、値を入れ替えてもインスタンスが生成されてしまうことである。
```java
User user = new User("hoge@fuga.co.jp", "hoge");  // 不正なオブジェクト
```

- このように不正なインスタンスを生成するとシステムに悪影響を及ぼすことになる。値オブジェクトを使用するとこのような事態を防ぐことが可能となる。
```java
class UserId {
    private String value;

    public UserId(String value) {
        if (value == null) throw new IllegalArgumentException("ユーザID が null です。");

        this.value = value;
    }
}

class MailAddress {
    private String value;

    public MailAddress(String value) {
        if (value == null) throw new IllegalArgumentException("メールアドレス が null です。");

        this.value = value;
    }
}

class User {
    private UserId userId;
    private MailAddress mailAddress;

    public User(UserId userId, MailAddress mailAddress) {
        if (userId == null) throw new IllegalArgumentException("UserId が null です。");
        if (mailAddress == null) throw new IllegalArgumentException("MailAddress が null です。");

        this.userId = userId;
        this.mailAddress = mailAddress;
    }
}
```
- userId も mailAddress も値オブジェクトで定義することにより、どちらか一方がもう一方のフィールドにセットされることは防ぐことができる。このように値オブジェクトを使用することで、些細なバグを事前に防ぐことができる。

#### ロジックの散在を防ぐ
- DRY原則にもあるように、ロジックの重複を防ぐことは重要である。コードの重複を許してしまうと、コード修正に対する工数が増大してしまう。ここでユーザの作成処理と更新処理を行う2つのメソッドを考えてみる。それぞれのメソッドはユーザ名の文字列が3文字以上の場合に作成、更新を行うような仕様となっている。コードは以下。

```java
public void createUser(String name) {
  if (name.length() < 3 || name == null) throw new IllegalArgumentException("ユーザ名が不正です。");
  
  User user = new User(name);
  ...
}

public void updateUser(String id, String name) {
  if (name.length() < 3 || name == null) throw new IllegalArgumentException("ユーザ名が不正です。");
  
  ...
}
```

- 上記のコードから分かるように createUser と updateUser は if 文の条件式が重複していることが分かるだろう。このような実装が引き起こす弊害はユーザ名のルールを変更する必要が出てきた場合に表れる。例えば最小文字数が3から4へ変更になった場合、createUser, updateUser をはじめ、最小文字数の判定を行なっている箇所全てを修正しなければならない。
- 言わずもがなルールを変更する場合はそれに伴う修正が1箇所であるのが望ましい。値オブジェクトをルールを集約させる場所として決めておくと、変更が容易なプログラムを作成することができる。

```java
class UserName {
  private String value;

  public UserName(String value) {
      if (value == null || value.length() < 3) throw new IllegalArgumentException("ユーザ名 が 不正です。");

      this.value = value;
  }
}

public void createUser(String name) {
    UserName userName = new UserName(name);
    User user = new User(userName);
    ...
}

public void updateUser(String id, String name) {
    UserName userName = new UserName(name);
    ...
}
```

### まとめ
- プリミティブな値ではなくドメインに含まれる知識を用いてシステムで取り扱う値として定義したオブジェクトを値オブジェクトと呼ぶ。
- 値オブジェクトを定義することで得られる恩恵は以下。
  - 値オブジェクトにドメイン固有のルールを定義することにより、オブジェクトの表現力が増し自己文書化を推し進めることができる。これによってソースコードに対する理解をより深めることができる。
  - 値オブジェクトにドメイン固有のルールを定義することにより、システムに不正な値が混入するのを防ぐことができ、安全なシステムを開発を進めることができる。
  - 値オブジェクトに振る舞いを定義することによりロジックの散在を防ぐことができ、変更容易性を高めることができる。