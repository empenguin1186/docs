<!-- TOC -->

- [ボトムアップでわかる! ドメイン駆動設計入門](#ボトムアップでわかる-ドメイン駆動設計入門)
  - [Chapter 1 ドメイン駆動設計とは](#chapter-1-ドメイン駆動設計とは)
    - [ドメイン駆動設計とは](#ドメイン駆動設計とは)
    - [ドメイン駆動設計のメリット](#ドメイン駆動設計のメリット)
    - [なぜ今ドメイン駆動設計か](#なぜ今ドメイン駆動設計か)
  - [Chapter 2 システム固有の値を表現する「値オブジェクト」](#chapter-2-システム固有の値を表現する値オブジェクト)
    - [値オブジェクトとは](#値オブジェクトとは)
    - [値オブジェクトの特徴](#値オブジェクトの特徴)
    - [値オブジェクトを採用するメリット](#値オブジェクトを採用するメリット)
    - [値オブジェクトを使用するケース](#値オブジェクトを使用するケース)
  - [Chapter 3 ライフサイクルのあるオブジェクト「エンティティ」](#chapter-3-ライフサイクルのあるオブジェクトエンティティ)
    - [エンティティとは](#エンティティとは)
    - [エンティティの特徴](#エンティティの特徴)
  - [Chapter 4 不自然さを解決する「ドメインサービス」](#chapter-4-不自然さを解決するドメインサービス)
    - [ドメインサービスとは](#ドメインサービスとは)
    - [ドメインサービスを使用するケース](#ドメインサービスを使用するケース)
  - [Chapter 5 データにまつわる処理を分離する「リポジトリ」](#chapter-5-データにまつわる処理を分離するリポジトリ)
    - [リポジトリとは](#リポジトリとは)
    - [リポジトリの責務](#リポジトリの責務)
    - [リポジトリの実装方針](#リポジトリの実装方針)
    - [リポジトリを使用するメリット](#リポジトリを使用するメリット)
  - [Chapter 6 ユースケースを実現する「アプリケーションサービス」](#chapter-6-ユースケースを実現するアプリケーションサービス)
    - [アプリケーションサービスとは](#アプリケーションサービスとは)
    - [アプリケーションサービスを実装するにあたっての注意事項](#アプリケーションサービスを実装するにあたっての注意事項)
  - [Chapter 9 複雑な処理を行う「ファクトリ」](#chapter-9-複雑な処理を行うファクトリ)
    - [ファクトリとは](#ファクトリとは)
    - [ファクトリを使用するケース](#ファクトリを使用するケース)
  - [Chapter 11 アプリケーションを1から組み立てる](#chapter-11-アプリケーションを1から組み立てる)
  - [Chapter 12 ドメインのルールを守る「集約」](#chapter-12-ドメインのルールを守る集約)
    - [集約とは](#集約とは)
    - [集約の特徴](#集約の特徴)
    - [集約の区切り方](#集約の区切り方)
  - [Chapter 13 複雑な条件を表現する「仕様」](#chapter-13-複雑な条件を表現する仕様)
    - [仕様とは](#仕様とは)
    - [仕様の実装内容](#仕様の実装内容)
    - [仕様を使用するケース](#仕様を使用するケース)
  - [Chapter 14 アーキテクチャ](#chapter-14-アーキテクチャ)
    - [アーキテクチャの役目](#アーキテクチャの役目)
    - [代表的なアーキテクチャ](#代表的なアーキテクチャ)
      - [レイヤードアーキテクチャ](#レイヤードアーキテクチャ)
      - [ヘキサゴナルアーキテクチャ](#ヘキサゴナルアーキテクチャ)
      - [クリーンアーキテクチャ](#クリーンアーキテクチャ)
- [社内向け発表のメモ](#社内向け発表のメモ)
  - [ドメイン駆動設計とは](#ドメイン駆動設計とは-1)
    - [ドメイン駆動設計とは何か](#ドメイン駆動設計とは何か)
    - [ドメインの知識に焦点を当てた設計手法](#ドメインの知識に焦点を当てた設計手法)
      - [ドメインとは](#ドメインとは)
      - [ドメインの知識に焦点を当てる](#ドメインの知識に焦点を当てる)
      - [ドメインモデル](#ドメインモデル)
      - [知識をコードで表現するドメインオブジェクト](#知識をコードで表現するドメインオブジェクト)
    - [ドメイン駆動設計における実装パターン](#ドメイン駆動設計における実装パターン)
      - [知識を表現するパターン](#知識を表現するパターン)
      - [アプリケーションを実現するためのパターン](#アプリケーションを実現するためのパターン)
      - [知識を表現する、より発展的なパターン](#知識を表現するより発展的なパターン)
  - [値オブジェクト](#値オブジェクト)
    - [値オブジェクトとは](#値オブジェクトとは-1)
    - [値の性質と値オブジェクトの実装](#値の性質と値オブジェクトの実装)
      - [不変である](#不変である)
      - [交換が可能である](#交換が可能である)
      - [等価性によって比較される](#等価性によって比較される)
    - [値オブジェクトにする基準](#値オブジェクトにする基準)
    - [振る舞いを持った値オブジェクト](#振る舞いを持った値オブジェクト)
    - [値オブジェクトを採用するモチベーション](#値オブジェクトを採用するモチベーション)
      - [表現力を増す](#表現力を増す)
      - [不正な値を存在させない](#不正な値を存在させない)
      - [誤った代入を防ぐ](#誤った代入を防ぐ)
      - [ロジックの散在を防ぐ](#ロジックの散在を防ぐ)
    - [まとめ](#まとめ)
  - [エンティティ](#エンティティ)
    - [エンティティとは](#エンティティとは-1)
    - [エンティティの性質について](#エンティティの性質について)
      - [可変である](#可変である)
      - [同じ属性であっても区別される](#同じ属性であっても区別される)
      - [同一性を持つ](#同一性を持つ)
    - [エンティティの判断基準としてのライフサイクルと連続性](#エンティティの判断基準としてのライフサイクルと連続性)
    - [値オブジェクトとエンティティのどちらにもなりうるモデル](#値オブジェクトとエンティティのどちらにもなりうるモデル)
    - [まとめ](#まとめ-1)
  - [ドメインサービス](#ドメインサービス)
    - [ドメインサービスとは](#ドメインサービスとは-1)
      - [不自然なふるまいを確認する](#不自然なふるまいを確認する)
      - [不自然さを解決するオブジェクト](#不自然さを解決するオブジェクト)
    - [ドメインサービスの濫用が行き着く先](#ドメインサービスの濫用が行き着く先)
      - [可能な限りドメインサービスを避ける](#可能な限りドメインサービスを避ける)
    - [物流システムに見るドメインサービスの例](#物流システムに見るドメインサービスの例)
      - [物流拠点の振る舞いとして定義する](#物流拠点の振る舞いとして定義する)
      - [輸送ドメインサービスを定義する](#輸送ドメインサービスを定義する)
    - [まとめ](#まとめ-2)
  - [アプリケーションサービス](#アプリケーションサービス)
    - [アプリケーションサービスとは](#アプリケーションサービスとは-1)
    - [アプリケーションサービスの実装例](#アプリケーションサービスの実装例)
      - [ドメインオブジェクトの定義](#ドメインオブジェクトの定義)
      - [リポジトリの定義、ドメインサービスの定義](#リポジトリの定義ドメインサービスの定義)
      - [ユーザ登録処理を作成する](#ユーザ登録処理を作成する)
      - [ユーザ情報取得処理を作成する](#ユーザ情報取得処理を作成する)
      - [ユーザ情報更新処理を作成する](#ユーザ情報更新処理を作成する)
      - [ユーザ退会を作成する](#ユーザ退会を作成する)
    - [アプリケーションサービスと凝集度](#アプリケーションサービスと凝集度)
    - [サービスについて](#サービスについて)
    - [まとめ](#まとめ-3)
  - [](#)

<!-- /TOC -->

# ボトムアップでわかる! ドメイン駆動設計入門

## Chapter 1 ドメイン駆動設計とは
- 以下の事項について説明できるようになることをゴールとする
  - ドメイン駆動設計とは
  - ドメイン駆動設計のメリット
  - なぜ今ドメイン駆動設計か

### ドメイン駆動設計とは
- ドメインの知識に焦点を当てた設計手法のことを指す。ここでいうドメインとは、プログラムを適用する対象領域のことを指す。例えば会計システムであれば帳票や金銭、配送システムでは倉庫や配送手段などがドメインに含まれる。ソフトウェアはユーザの課題を解消するために存在するので、その目的を果たすために役立つ知識や概念をドメインに含めて開発を行う必要がある。

### ドメイン駆動設計のメリット
- 汎用的なソフトウェアの設計のパターンを身に付けることができるので、設計段階で理想を現実に適合する場合に取るべき選択肢を増やしてくれる。
- ドメイン駆動設計によって開発されたソフトウェアは変更容易性が高くなる。

### なぜ今ドメイン駆動設計か
- ドメイン駆動設計が提唱されたのは2003年ごろと歴史があるものとなっているが、一昔前のソフトウェア開発はいち早く開発を完了しリリースすることが最も重要であると考えられていた。そのような背景から開発初期段階にモデリングに時間をかけるドメイン駆動設計は選択肢には入らなかった。しかし、速度を重視した開発は柔軟性や変更容易性が低いソフトウェアを生み出し、開発が進むにつれて場当たり的な修正を行う羽目になった。やがて開発者たちは速度よりも変更容易性の高いソフトウェアを開発することを望むようになり、結果としてドメイン駆動設計が注目されるようになった。

## Chapter 2 システム固有の値を表現する「値オブジェクト」
- 以下の事項について説明できるようになることをゴールとする
  - 値オブジェクトとは
  - 値オブジェクトの特徴
  - 値オブジェクトを採用するメリット
  - 値オブジェクトを使用するケース

### 値オブジェクトとは
システム固有の値を表したオブジェクトのことを指す。例えば、姓と名で構成される FullName を考えたときに、名前なのでプリミティブな String 型でも表現することができるが、FullNameクラスを定義することによって姓名それぞれを特定することが容易となって汎用性が高くなる。

### 値オブジェクトの特徴
- 値が不変
- 交換(代入)が可能である
  - 値オブジェクトの内部の値は不変だが、値オブジェクト自体は代入することができる。
- 等価性によって比較される
  - 同一性ではなく、等価性によって比較される。そのためには、比較用のメソッドを実装する必要がある。
- 属性が追加されても修正不要
  - 値オブジェクトに関する判定処理を値オブジェクト自身で実装することにより、変更箇所を最小限に留めることができる。

### 値オブジェクトを採用するメリット
- 表現力を増す
  - 単なるプリミティブ型で値を表現するより、ルールが表現されている値オブジェクトを使用した方が、どのような処理を行なっているのか、メソッドやコンストラクタの場合引数にどのようなものが渡されているのかが理解しやすくなる。
- 不正な値を存在させない
  - 「ユーザ名はN文字以上」といったルールをコンストラクタに組み込むことで、不正な値が入力されたことによる異常事態をいち早く気づくことができる。
- 誤った代入を防ぐ
  - 型を定義することにより、誤った代入が行われるのを防ぐ。例えば、本来ならユーザ名を代入するところをパスワードを代入したしまったケースなど。
- ロジックの散在を防ぐ
  - 値オブジェクトに関するロジックは値オブジェクトで定義した方が、ロジックがもし変更された場合でもクライアントのコードの変更は行わなくてもよくなるので、変更容易性が高いコードを作成することができる。

### 値オブジェクトを使用するケース
- まず、どの概念を値オブジェクトで表現するかだが、基準として何かの業務ルールが存在する場合は値オブジェクトの作成を検討する。例えば、パスワードを設定する際に文字数の制限や使用できる文字の種類が決まっている場合はパスワードを単なるプリミティブ型で表現するのではなく、値オブジェクトとして表現した方が良い。

## Chapter 3 ライフサイクルのあるオブジェクト「エンティティ」
- 以下の事項について説明できるようになることをゴールとする
  - エンティティとは
  - エンティティの特徴

### エンティティとは
- エンティティとは、同一性で区別されるオブジェクトのことを指す。例えば、システムのユーザの多くは自身でユーザの情報を変更することができるが、情報を変更したからといってユーザ自身が変更後別のユーザになるということはない。こういったオブジェクトのことをエンティティと呼ぶ。

### エンティティの特徴
- 可変である
  - 値オブジェクトと異なり、エンティティは可変の要素をもつ(ユーザの身長など)場合が存在する
- 同じ属性であっても区別される
  - 姓名は属性であり、同姓同名の人間が同じ人間かと言われると違うように、エンティティも属性が同じだからとはいえ同じものだと区別はされない。
- 同一性により区別される
  - ユーザ情報を変更したからといって変更前と変更後は違うユーザとなるということはない。これはユーザは同一性の検証によって同じユーザであると判定されているためである。したがってエンティティの同一性を検証する方法が必要だが、大抵はIDなどを元に同一性を検証することとなる。

## Chapter 4 不自然さを解決する「ドメインサービス」
- 以下の事項について説明できるようになることをゴールとする
  - ドメインサービスとは
  - ドメインサービスを使用するケース

### ドメインサービスとは
- ドメインサービスとは、値オブジェクトやエンティティで実装するには直感的でなくきまりが悪いロジックを実装するクラスのことを指す。例えば、そのユーザ名が既に存在しているかどうかの検証メソッドを実装する場合、エンティティ自身にこのロジックを実装させるのはいささか違和感が伴う。ここでドメインサービスでこの検証処理を実装すれば不自然さを解消することができる。

### ドメインサービスを使用するケース
- まず、なんでもかんでもドメインサービスにロジックを実装すべきではない。値オブジェクトやエンティティの表現力が低下するからである。これをドメインモデル貧血症と呼ぶ。可能な限りドメインサービスでロジックを実装することは避け、どうしてもロジックが値オブジェクトやエンティティの責務ではない場合にのみ実装する。

## Chapter 5 データにまつわる処理を分離する「リポジトリ」
- 以下の事項について説明できるようになることをゴールとする
  - リポジトリとは
  - リポジトリの責務
  - リポジトリの実装方針
  - リポジトリを使用するメリット

### リポジトリとは
- リポジトリは、データストアなどを使用してデータの永続化や再構築を行うためのオブジェクトのことをさす。

### リポジトリの責務
- リポジトリはデータの永続化や再構築を行うオブジェクトなので、ドメインロジックはリポジトリでは実装すべきではない。ドメインオブジェクトはあくまでドメインサービスや値オブジェクト、エンティティで実装する。

### リポジトリの実装方針
- リポジトリは基本的にはインターフェースを切って実装を行う

### リポジトリを使用するメリット
- データストアへの接続やSQLの発行をリポジトリで実装することにより、ドメインサービスではそれらの処理を気にせずにロジックを組み立てることができる
- テストを実行する場合はテスト用のリポジトリを定義することによって実際にデータストアを使用することなくテストを実行することができる。

## Chapter 6 ユースケースを実現する「アプリケーションサービス」
- 以下の事項について説明できるようになることをゴールとする
  - アプリケーションサービスとは
  - アプリケーションサービスを実装するにあたっての注意事項
  - アプリケーションサービスを使用するケース

### アプリケーションサービスとは
- ドメインサービスとは異なり、ドメインオブジェクトを組み合わせてシステムを利用するユーザが取りうるアクション(サービス利用開始、基本情報変更、退会 etc...)を体現するのがアプリケーションサービスである。

### アプリケーションサービスを実装するにあたっての注意事項
- アプリケーションサービスでクライアントにドメインオブジェクトをそのまま渡すのは避けるべきである。なぜならドメインオブジェクトを渡すとクライアント側でもドメインロジックを実行することができてしまい、ドメインロジックを実行するという責務をあらゆる層が持つことになるからである。これを避けるためにアプリケーションサービスはドメインオブジェクトではなく Data Transfer Object (DTO)を渡すことがあげられる。
- アプリケーションサービスではドメインロジックを実装するべきではない。あくまでアプリケーションサービスはドメインオブジェクトやそのメソッドを呼び出すにとどめておく。例えば、ユーザの検索処理はアプリケーションサービスで実装すると、検索処理自体のロジックを変更する場合にはそれぞれ使用している箇所を全て修正しなければならないが、ドメインサービスで実装すればアプリケーションサービスはその修正したメソッドを呼び出すだけで機能を修正できる。
- アプリケーションサービスはなるべく凝集度を高くすることが重要である。凝集度をはかる指標としてLCOMというものが存在し、これはクラスのフィールドがどのメソッドで使用されているかを測る物である。
- アプリケーションサービスをインターフェースとして定義すると、クライアントはそのインターフェースを使用することにより、実装完了を待たずしてクライアント側の処理を実装できる。

## Chapter 9 複雑な処理を行う「ファクトリ」
- 以下の事項について説明できるようになることをゴールとする
  - ファクトリとは
  - ファクトリを使用するケース

### ファクトリとは
- 複雑なオブジェクトの生成処理を定義したオブジェクトのことを向上となぞらえてファクトリと呼ぶ。ファクトリを定義することにより、クライアントはオブジェクトを生成するに至るまでの複雑な処理の過程を知ることなく目的のオブジェクトを生成することができる

### ファクトリを使用するケース
- インスタンスを生成するという観点から、ファクトリはコンストラクタと責務が同じであると捉えることができるが、コンストラクタとの使い分けに関しては、コンストラクタはインスタンスの生成が比較的単純な場合に使用する。コンストラクタの中で別のオブジェクトを生成するようなことがあった場合、そのオブジェクトが変更されたらコンストラクタも変更する恐れがあるのでこういった場合はファクトリで実装した方が良い。

## Chapter 11 アプリケーションを1から組み立てる
- アプリケーションを作成するフローについて説明できるようにする
- デモンストレーションを通して気づいた点をまとめる

## Chapter 12 ドメインのルールを守る「集約」
- 以下の事項について説明できるようになることをゴールとする
  - 集約とは
  - 集約の特徴
  - 集約の区切り方
  - 集約を使用するケース

### 集約とは
- オブジェクトの不変条件を適用する単位。集約を定義することにより、オブジェクトに秩序をもたらす。例えば、以下のように Circle の名前を変更する擬似コードを考える

```kt
val circle = Circle()
circle.name = "CircleA"  // 1.
circle.changeName("CircleA")  // 2.
```
1. より2. が優れている点としては、メソッドで切り出したことにより不変条件(名前が〇〇文字以上になっているかどうか、null が指定されていないか)の判定を行うことができるところにある。ここで変更を命令を問い合わせる対象である circle のことを集約ルートと呼ぶ。また、Circle には name の他に、member, equipment などのプロパティも存在することが考えられる。こういった集約内に存在する要素のことを境界と呼ぶ。

### 集約の特徴
- 不変条件を適用する一つの単位である
- オブジェクトに変更を加える場合は集約ルートに対して問い合わせるしかないので、むやみやたらに外部から状態を変更されることを防ぐことができる

### 集約の区切り方
- ある集約から異なる集約の要素を変更するような実装は避ける。
- 集約はできるだけ小さく保つ。複数のトランザクションを張る場合はそれ全体を集約として扱わない方が良い。

## Chapter 13 複雑な条件を表現する「仕様」
- 以下の事項について説明できるようになることをゴールとする
  - 仕様とは
  - 仕様の実装内容
  - 仕様を使用するケース

### 仕様とは
- アプリケーションを作成するにあたりオブジェクトに対する判定ロジックを実装するのはよくあることである。単純なロジックはそのオブジェクトに実装すれば良いが、複雑な判定ロジックを実装する場合には、仕様に基づいて判定を行うオブジェクトを別途定義し判定を行わせるのも一つの手である。
- 例えば User のタイプに応じて Circle の人数の上限を変更するケースを考える。ここで Circle オブジェクトが集約の観点から User そのものではなく UserId を内部で保持している場合、上限を判定するロジックを Circle オブジェクトで実装する場合、 Repository クラスをメソッドに渡して上げる必要がある。しかし、ドメインオブジェクトである Circle に本来DDDの概念ではない Repository を追加することは望ましくない。したがって Circle オブジェクトと Repository を受け取って上限を判定する仕様オブジェクトを作成するのが望ましい。また、Repositoryを渡さずともアプリケーションサービスで Repository からUserを取得し、そのリストを渡してあげることでも実現可能である。この場合仕様もドメインオブジェクトのみで構成されるので一貫性を保つことができる

### 仕様の実装内容
- 仕様の適用をアプリケーションサービスで行うか、Repository に仕様インターフェースを渡して判定を行うかの２択が存在する。

### 仕様を使用するケース
- あるリストに対して何かフィルタリングを行うような場合に有効な考え方の一つである。

## Chapter 14 アーキテクチャ
- 以下の事項について説明できるようになることをゴールとする
  - アーキテクチャの役目
  - 代表的なアーキテクチャ
    - レイヤードアーキテクチャ
    - ヘキサゴナルアーキテクチャ
    - クリーンアーキテクチャ

### アーキテクチャの役目
- ECサイトを例にあげて説明すると、ECサイトで注文詳細、履歴、購入確定画面で合計金額を表示する場合、各画面で合計金額を計算するロジックを実装していると、計算ロジックに変更が発生した場合には全ての画面のロジックの変更を余儀なくされ、修正コストが高くなる。したがってUIには極力ロジックを持たせない方が良い。ロジックを持ったUIを「利口なUI」と呼ぶ。こういったケースの解決策としては、サーバ側で計算ロジックを実装し、UIはその結果を受け取って表示するだけに止めることである。
- 上記のUIの例でもあるように、ロジックを適切な箇所に実装することはソフトウェアを開発する際には重要である。そのロジックをどこに実装するかの指針を示しているのがアーキテクチャと呼ばれるものである。

### 代表的なアーキテクチャ
#### レイヤードアーキテクチャ
- プレゼンテーション層、アプリケーション層、ドメイン層、インフラストラクチャ層で構成されるアーキテクチャ。プレゼンテーション -> アプリケーション -> ドメイン -> インフラストラクチャ という依存の矢印をもち、下位層は上位層に依存してはならない。

#### ヘキサゴナルアーキテクチャ
- 入力と出力の実装に依存せずにドメインロジックを守るように設計されたアーキテクチャ。入力と出力にはそれぞれアダプタとポートが存在し、それぞれアダプタがクライアント、ポートが実行するメソッドのことを指す。アダプタがポートに必要なの引数のインスタンスを生成し、ポートが実際にそれを用いて処理を実行する。ポートはインターフェースで定義されているため、入力と出力の汎化を実現している。

#### クリーンアーキテクチャ
- クリーンアーキテクチャはヘキサゴナルアーキテクチャと似ているが、ヘキサゴナルと異なる点として具体的な実装方針が述べられている点である。Controller -> Use Case Input Port(I) <|- Use Case Interactor -> Use Case Output Port(I) <|- Presenter といった依存、汎化関係が存在し、処理のフローは Controller -> Use Case Interactor -> Presenter の順となる。Controller は User Case は Use Case Input Port 越しに Interactor を呼び出すので、スタブを用意することでテストを容易に実行することができる。また Use Case Interactor も Use Case Output Port 越しに Presenter を呼び出すので、同様にテスト容易性を高めることができる。このようにドメインロジックを隔離できるのがクリーンアーキテクチャの利点である。


# 社内向け発表のメモ

## ドメイン駆動設計とは

### ドメイン駆動設計とは何か
- 我々がユーザにとって役立つソフトウェアを開発するためには、まずそのソフトウェアの利用者の課題や取り巻く世界について学ぶ必要がある。物流システムを構築する際には物流に関する知識を、会計システムを構築するには金融の知識を学ぶ必要があるだろう。しかし、その世界には様々な知識が存在し、どの知識がソフトウェア開発に役立つかは取捨選択をしなければならない。例えば物流システムにおいてはトラックの積載量や輸送ルートといった知識は物流システムにおいて利用価値が高いものだと言えるが、トラックの語源がラテン語の「trochus」で、その意味が「鉄の輪」であるという知識は利用価値は低いものであることが判断できるだろう。このようにソフトウェア開発においてはその取り巻く世界に関する知識を有効かどうかを取捨選択し、有効であると判断された知識をコードに落とし込んでいくことが必要となる。ドメイン駆動開発はユーザのニーズから必要な知識が何であるかの洞察を繰り返し、実装に結びつけることを目的としている。

### ドメインの知識に焦点を当てた設計手法

#### ドメインとは
- ドメインは「領域」の意味を持った言葉であり、ソフトウェア開発におけるドメインは「プログラムを適用する対象となる領域」を指す。したがって開発するソフトウェアによってドメインはそれぞれ異なる。例えば、物流システムに関しては貨物や倉庫、輸送手段などの概念がドメインに含まれ、会計システムでは金銭や帳票といった概念がドメインに含まれる。

#### ドメインの知識に焦点を当てる
- ソフトウェアには必ずユーザが存在する。より良いソフトウェアを開発するためにはそのユーザが抱えている課題やニーズを正確に理解することが必要である。ユーザがどんな課題を解決したいと思っているのか、どのようなニーズを持っているのかを知るためには、ユーザの視点や考え、取り巻く環境を理解する必要がある。したがってドメインと向き合うことが必要となる。
- ドメインの概念や事象を理解し、その中から課題解決に役立つものを抽出して得られた知識をソフトウェアに反映するという作業は当たり前の行為である。しかし、技術指向の開発者であればあるほどこの工程をおろそかにしがちである。最新のフレームワークや開発手法にばかり目がいってしまい、ドメインを向き合わずにソフトウェアを開発していくと結果ユーザのニーズとは的外れのソフトウェアが出来上がってしまうなんていうこともあり得る。したがってこのような事態を招かないようにするためにも、ソフトウェアに適用する範囲をしっかりと把握し、関係する知識に焦点を当てる必要がある。

#### ドメインモデル
- 「ドメインモデル駆動設計とは何か」の項で、ドメインに含める知識は取捨選択する必要があるということを述べたが、そうやって現実の事象や概念をある程度抽象化したものをドメインモデルと呼ぶ。ドメインモデルは現実世界をそのまま表現するということはしない。例えば、ペンについて考えてみると、小説家にとってペンは文字を書けるという特性が一番重要なので、その性質がドメインモデルに反映されることになるが、文房具店にとってはペンは商品の一部なので、在庫やその値段といった性質が重要となる。したがってそれらがドメインモデルに反映されることになる。このことから、ドメインモデルに反映されるものはコンテキストによって異なるということである。
- 現実世界は複雑なので、ドメインモデルを構築する場合に現実世界の知識を忠実に再現するのは不可能であるし再現する必要もない。ソフトウェア開発に役立つ知識のみピックアップして表現することができればそれで十分だし、実装も現実的なものになる。こういったモデルを構築する知識を取捨する行為をモデリングと呼ぶ。

#### 知識をコードで表現するドメインオブジェクト
- ドメインモデルをコードで表現したものをドメインオブジェクトと呼ぶ。ドメインで起こった変化はドメインモデルに伝わり、そのコード表現であるドメインオブジェクトにまで反映されることになる。逆にドメインで起こった変化がドメインオブジェクトで表現することが難しいと判断された場合は、ドメインで起こった変化を見直すというアクションが取られる。このようにドメインとドメインオブジェクトは相互に影響し合う関係性にある。

### ドメイン駆動設計における実装パターン
- ドメイン駆動設計には様々な概念が登場する。混乱を避けるために大まかにグルーピングして説明していく

#### 知識を表現するパターン
- 最初にドメインに含まれる知識を表現するパターンについて説明する。具体的に説明するパターンは以下のオブジェクト。
  - 値オブジェクト
    - ドメイン固有の概念を値として表現するオブジェクト。
  - エンティティ
    - ドメイン固有の概念を表現するという意味では値オブジェクトと同じであるが、値オブジェクトと対をなす性質をもつオブジェクト。
  - ドメインサービス
    - 値オブジェクトやエンティティでは表現できない知識を取り扱うためオブジェクト。

#### アプリケーションを実現するためのパターン
- ドメインに含まれる知識を表現しただけではソフトウェアの要件を満たしていない。そこでソフトウェアの要件を満たすために必要なパターンについて説明する。
  - リポジトリ
    - データの保存や復元といった永続化や再構築を再現するオブジェクト。外部のデータストアに対する操作を抽象化することでソフトウェアに柔軟性を持たせる。
  - アプリケーションサービス
    - 値オブジェクト、エンティティ、ドメインサービス、リポジトリをうまく強調させてアプリケーションとしての機能を表現するオブジェクト。
  - ファクトリ
    - 生成が複雑であるオブジェクトの生成を担当するファクトリ。ファクトリを使用するオブジェクトにとってはその生成処理を隠蔽することでオブジェクトの使用を容易にする。また、生成処理をファクトリに集中させることで処理の目的を明確にするという役割もある。

#### 知識を表現する、より発展的なパターン
- 知識を表現するより発展的なパターンについてのべる。
  - 集約
    - 整合性を保つ境界をさす。値オブジェクトやエンティティを複合してより複雑なドメインの概念を表現する。
  - 仕様
    - オブジェクトの評価をモジュール化したもの

## 値オブジェクト

### 値オブジェクトとは

- 値オブジェクトがなんであるかを理解してもらうため、名前をコードでどのように表現するかを考えてみる。一番簡単な方法は以下のように String クラスで定義することが考えられるだろう。
```java
String fullName = "Yahoo Taro";
```

- この fullName はそのまま使用されることもあるし、姓だけ使用する場合も考えられるだろう。そうなった場合には以下のような処理を実装する必要がある。
```java
String[] tokens = full.split(" ");
String lastName = tokens[0];  // Yahoo
String firstName = tokens[1]; // Taro
```

- 一見これは正しい実装に見えるが、場合によっては間違った実装となる。以下のようなケースである。
```java
String fullName = "John Smith";
String[] tokens = full.split( " ");
String lastName = tokens[0]; // John
String firstName = tokens[1]; // Smith
```

- 現実世界には先頭に名が来るケースが存在するので上記のような実装は場合によっては不具合が生じてしまう。これを避けるためにクラスを利用するパターンが存在する。
```java
class FullName {

  private String firstName;
  private String lastName;

  public FullName(String firstName, String lastName) {
      this.firstName = firstName;
      this.lastName = lastName;
  }

  public String getFirstname() {
      return firstName;
  }

  public String getLastname() {
      return lastName;
  }
}
```
- この例からわかるのは、システムに最適な値が必ずしもプリミティブな値であるとは限らないということである。このようにシステム固有の値を表したオブジェクトを値オブジェクトと呼ぶ。

### 値の性質と値オブジェクトの実装
- 値の性質について取り上げながら値オブジェクトの特徴について説明する。主な特徴については以下の3つ。
  - 不変である
  - 交換が可能である
  - 等価性によって比較される

#### 不変である
- 値の性質に不変というものがある。以下のコードを考える。
```java
1 = 0; // 値の変更(擬似コード)

if (1 == 0) {
  System.out.println("num is 0")
}
```
- 値の変更が可能であると仮定するれば、上記のコードを実行した場合、「num is 0」という出力結果が得られるだろう。しかしご存知の通りこのコードはコンパイルエラーとなり、プログラムとしての要件を満たしていない。1はどこまでいっても1という値をとり、0はどこまでいっても0という値をとる必要がある。すなわち不変である必要がある。でなければ安全に値を使用することができない。
- この性質にならい値オブジェクトも不変にするのが望ましい。不変にすることで、プログラムの途中で値が変更されるという事態がなくなり、予期せぬバグを防ぐことができる。

#### 交換が可能である
- 値は不変である必要があるということを前項で述べたが、値を変更せずにソフトウェアを開発することは難しい。なんらかの処理に応じて値を変更するなんてケースは必ず発生するだろう。その場合は値の変更ではなく交換することで目的を達成できる。

```java
FullName fullName = new FullName("Yahoo", "Taro");
fullName = new FullName("Smith", "John");
```
- 値そのものを変更するのではなく、異なる値を用意して交換を行うことで変更を行わずしてオブジェクトの状態を変更することができる。

#### 等価性によって比較される
- 値同士の比較を行う場合、結果は以下のようになる
```java
0 == 0 // true
1 == 0 // false
'a' == 'a' // true
'b' == 'b' // false
"hello" == "hello" // true
"hello" == "こんにちは" // false
```
- この例からわかることは、値に関しては別のインスタンスであっても、属性が一致していれば等価であると判断される(同一性は気にしない)。値オブジェクトもインスタンスが同一かどうかではなく、属性によって等価性が判断される。
- また、値オブジェクトは値オブジェクトそのものを比較するメソッドを実装する方が自然な記述となる。以下が実装例となる。
```java
class FullName {

  private String firstName;
  private String lastName;
  
  ...

  @Override
  public boolean equals(Object obj) {
      FullName other = (FullName) obj;
      return this.firstName.equals(other.getFirstname()) && this.lastName.equals(other.getLastname());
  }

  @Override
  public int hashCode() {
      int result = this.firstName.hashCode();
      result = 31 * result + this.lastName.hashCode();
      return result;
  }
}
```

- この実装によって以下のような値オブジェクト同士の比較が可能となる。
```java
FullName a = new FullName("Yahoo", "Taro");
FullName b = new FullName("John", "Smith");

if (a.equals(b)) {
  ...
}
```
- 等価性を判断するメソッドを実装するメリットは記述の自然さをもたらすことだけではない。例えばFullNameクラスに middleName というフィールドを追加することになり、それに伴いequalsメソッドを改修しなければならない場合、以下のように FullName クラスの equals メソッドのみを改修するだけで良い。

```java
class FullName {
  private String firstName;
  private String middleName
  private String lastName;
  
  @Override
  public boolean equals(Object obj) {
      FullName other = (FullName) obj;
      return this.firstName.equals(other.getFirstname()) && this.middleName.eqals(other.getMiddleName()) && this.lastName.equals(other.getLastname());
  }
}
```
- 一方以下のように FullName クラスを使用する側で判断のメソッドを実装している場合は、各使用箇所で修正を行う必要があり、場合によっては手間がかかる場合がある。このようにロジックを集中させることで無駄な修正を減らすことができるのも値オブジェクトを実装するメリットである。

```java
if (a.getFirstName().equals(b.getFirstName()) && a.getMiddleName().equals(b.getMiddleName()) && a.getLastName().equals(b.getLastName())) {
  ...
}
```

### 値オブジェクトにする基準
- どのような概念を値オブジェクトとして実装すればいいのかという判断は、「そこにルールが存在しているか」という点と「それ単体で扱いたいか」という観点で考えるとよい。例えば FullName クラスは姓と名で構成され、かつ単体で使用したいので値オブジェクトとして取り扱うのが望ましいだろう。またこの場合に firstName と lastName は現状システム的なルールは存在しない。これに文字数制限や文字種制限などが課せられた場合は値オブジェクトにすることを検討した方が良い。

### 振る舞いを持った値オブジェクト

- 値オブジェクトの重要な特性として、独自の振る舞いを定義できることが挙げられる。ここでお金に関するオブジェクトについて考える。お金には金額と通貨単位(円、ドル etc...)の2つの属性がある。これを値オブジェクトとして定義すると以下のようになる。
```java
class Money {
  private int amount;
  private Currency currency;

  public int getAmount() {
      return amount;
  }

  public Currency getCurrency() {
      return currency;
  }

  public Money(int amount, Currency currency) {
      if (currency == null) throw new IllegalArgumentException("通貨単位が null です。");
      this.amount = amount;
      this.currency = currency;
  }

  public Money add(Money arg) {
      if (arg == null) throw new IllegalArgumentException("加算対象が null です。");
      if (arg.getCurrency().equals(this.currency)) throw new IllegalArgumentException("通貨単位が異なります。");
      
      return new Money(this.amount + arg.getAmount(), this.currency);
  }
}

enum Currency {
    JPY,
    USD
}
```
- add メソッドはお金同士の加算を行うメソッドである。加算を行う際に異なる通貨単位のお金を加算しようとしたら例外がスローされるような実装となっている。この実装によるメリットは、このお金オブジェクトの使用者が誤って異なる通貨単位のお金を加算しようとした場合には即座に間違いに気づけるという点である。このように、値オブジェクト自体にドメインの知識に基づくルールを定義しておくことで、間違った操作による不具合を防ぐことができる。

### 値オブジェクトを採用するモチベーション
- 値オブジェクトを定義するとなると、当然のように多くのクラスを定義しなければならなくなり、煩雑であると感じることもあるだろう。そういった心理的ハードルを乗り越えてまで値オブジェクトを定義する必要があるのか疑問に感じることもあると思う。したがってこの項では値オブジェクトを採用するモチベーションについてのべる。値オブジェクトを採用するモチベーションとしては以下の4点が挙げられる。順を追って説明していく。
  - 表現力を増す
  - 不正な値を存在させない
  - 誤った代入を防ぐ
  - ロジックの散在を防ぐ

#### 表現力を増す

- 工業製品を例にとって説明しよう。工業製品にはロット番号やシリアル番号、製品番号など識別するための様々な番号が存在している。それらは数字だけで構成されることもあれば、アルファベットも含めた文字列で表されることもある。製品番号をプリミティブな値で表現するのなら、以下のような定義になるだろう。
```java
String modelNumber = "a20421-100-1";
```

- このように明確に変数宣言がされている場合は製品番号がどのようなフォーマットであるかを把握することはできる。しかし、以下のようにいきなりプログラムに出現した場合はどのようなフォーマットをしているのかはプログラムを遡ったりデバッグをしない限り把握するのは難しいだろう。
```java
void doSomething(String modelNumber) {
  ...
}
```

- 一方値オブジェクトを用いて製品番号を表現する場合は以下のようになる。
```java
class ModelNumber {
  private String productCode;
  private String branch;
  private String lot;

  public ModelNumber(String productCode, String branch, String lot) {
      if (productCode == null) throw new IllegalArgumentException("productCode が null です。");
      if (branch == null) throw new IllegalArgumentException("branch が null です。");
      if (lot == null) throw new IllegalArgumentException("lot が null です。");

      this.productCode = productCode;
      this.branch = branch;
      this.lot = lot;
  }

  @Override
  public String toString() {
      return this.productCode + "-" + this.branch + "-" + this.lot;
  }
}
```
- 値オブジェクトとして定義すると、製品番号はプロダクトコード(productCode)と枝番(branch)とロット番号(lot)から構成されることがコードから把握することができる。このように、値オブジェクトはその定義により自身がどういったオブジェクトであるかという自己文書化を推し進める。

#### 不正な値を存在させない
- ユーザ名を例にとって説明しよう。ユーザ名には大体「M文字以上N文字以下」、「利用できる文字はアルファベットと数字のみ」といったルールが存在する。例えば「ユーザ名は3文字以上」というルールがあったとして、以下のようなユーザ名はシステム的には異常な値である。
```java
String userName = "me"
```

- しかし、これはシステム的にはルールに違反しているが、プログラムとしてはとりうる値なので実行したところで何も問題なく動作する。したがって不正が値が混入したまま処理が行われることなり、結果的にシステム不具合が生じてしまう。一度このような異常な値の混入を許してしまうと、システム側で逐一以下のような値チェックを行う必要が出てくる。
```java
if (userName.length() >= 3) {
  // 正常な値なので処理を続行する
} else {
  throw new Exception("不正な値です。");
}
```

- しかし、このような値のチェックを行う箇所が複数になってくると、修正漏れが一つでもあった場合には再び異常な値の混入を許してしまう。そこで、以下のように値オブジェクトを利用することで異常な値の混入を防ぐことができる。
```java
class UserName {
  private String value;

  public UserName(String value) {
      if (value == null) throw new IllegalArgumentException("ユーザ名 が null です。");
      if (value.length() < 3) throw new IllegalArgumentException("ユーザ名は3文字以上でなければなりません。");
      
      this.value = value;
  }
}
```

- コンストラクタのガード節により UserName の生成に成功した段階で3文字以上のユーザ名のみ処理対象になることが担保され、システムで不具合が発生することを防ぐことができる。

#### 誤った代入を防ぐ

- あるシステムのユーザのオブジェクトを例にとって考える。ユーザはユーザIDとメールアドレスという属性を持っているとする。それぞれをプリミティブな値で定義した User クラスは以下のようになる。
```java
class User {
  private String userId;
  private String mailAddress;

  public User(String userId, String mailAddress) {
      if (userId == null) throw new IllegalArgumentException("UserId が null です。");
      if (mailAddress == null) throw new IllegalArgumentException("MailAddress が null です。");

      this.userId = userId;
      this.mailAddress = mailAddress;
  }
}
```

- このクラスのインスタンスを生成する場合は以下のようなコードを記述することになるだろう。
```java
User user = new User("hoge", "hoge@fuga.co.jp");
```

- ここで問題となるのは、userId フィールドも mailAddress フィールドも String で定義されているため、値を入れ替えてもインスタンスが生成されてしまうことである。
```java
User user = new User("hoge@fuga.co.jp", "hoge");  // 不正なオブジェクト
```

- このように不正なインスタンスを生成するとシステムに悪影響を及ぼすことになる。値オブジェクトを使用するとこのような事態を防ぐことが可能となる。
```java
class UserId {
    private String value;

    public UserId(String value) {
        if (value == null) throw new IllegalArgumentException("ユーザID が null です。");

        this.value = value;
    }
}

class MailAddress {
    private String value;

    public MailAddress(String value) {
        if (value == null) throw new IllegalArgumentException("メールアドレス が null です。");

        this.value = value;
    }
}

class User {
    private UserId userId;
    private MailAddress mailAddress;

    public User(UserId userId, MailAddress mailAddress) {
        if (userId == null) throw new IllegalArgumentException("UserId が null です。");
        if (mailAddress == null) throw new IllegalArgumentException("MailAddress が null です。");

        this.userId = userId;
        this.mailAddress = mailAddress;
    }
}
```
- userId も mailAddress も値オブジェクトで定義することにより、どちらか一方がもう一方のフィールドにセットされることは防ぐことができる。このように値オブジェクトを使用することで、些細なバグを事前に防ぐことができる。

#### ロジックの散在を防ぐ
- DRY原則にもあるように、ロジックの重複を防ぐことは重要である。コードの重複を許してしまうと、コード修正に対する工数が増大してしまう。ここでユーザの作成処理と更新処理を行う2つのメソッドを考えてみる。それぞれのメソッドはユーザ名の文字列が3文字以上の場合に作成、更新を行うような仕様となっている。コードは以下。

```java
public void createUser(String name) {
  if (name.length() < 3 || name == null) throw new IllegalArgumentException("ユーザ名が不正です。");
  
  User user = new User(name);
  ...
}

public void updateUser(String id, String name) {
  if (name.length() < 3 || name == null) throw new IllegalArgumentException("ユーザ名が不正です。");
  
  ...
}
```

- 上記のコードから分かるように createUser と updateUser は if 文の条件式が重複していることが分かるだろう。このような実装が引き起こす弊害はユーザ名のルールを変更する必要が出てきた場合に表れる。例えば最小文字数が3から4へ変更になった場合、createUser, updateUser をはじめ、最小文字数の判定を行なっている箇所全てを修正しなければならない。
- 言わずもがなルールを変更する場合はそれに伴う修正が1箇所であるのが望ましい。値オブジェクトをルールを集約させる場所として決めておくと、変更が容易なプログラムを作成することができる。

```java
class UserName {
  private String value;

  public UserName(String value) {
      if (value == null || value.length() < 3) throw new IllegalArgumentException("ユーザ名 が 不正です。");

      this.value = value;
  }
}

public void createUser(String name) {
    UserName userName = new UserName(name);
    User user = new User(userName);
    ...
}

public void updateUser(String id, String name) {
    UserName userName = new UserName(name);
    ...
}
```

### まとめ
- プリミティブな値ではなくドメインに含まれる知識を用いてシステムで取り扱う値として定義したオブジェクトを値オブジェクトと呼ぶ。
- 値オブジェクトを定義することで得られる恩恵は以下。
  - 値オブジェクトにドメイン固有のルールを定義することにより、オブジェクトの表現力が増し自己文書化を推し進めることができる。これによってソースコードに対する理解をより深めることができる。
  - 値オブジェクトにドメイン固有のルールを定義することにより、システムに不正な値が混入するのを防ぐことができ、安全なシステムを開発を進めることができる。
  - 値オブジェクトに振る舞いを定義することによりロジックの散在を防ぐことができ、変更容易性を高めることができる。

## エンティティ

### エンティティとは
- 値オブジェクトもエンティティもドメインモデルを実装したドメインオブジェクトである。両者の違いは同一性によって識別されるか否かにある。同一性ではなく同値性で識別されるオブジェクトを値オブジェクト、同一性で識別されるオブジェクトをエンティティとしている。
- 人間を例にとって考えてみよう。人間には体重や年齢、身長といった属性が存在するが、それらが変化したとして別の人間であると言えるだろうか？おそらく言えないであろう。何故ならばたとえ属性が変化したとしても戸籍は同じであり、同一人物であると識別されるからである。これが同一性によって識別されるということである。ソフトウェアシステムについても考えてみると、あるユーザがユーザ名などのユーザ情報を変更したとしても、全く別のユーザになってしまうということはあり得ない。ユーザ情報を変更しただけであって、ユーザそのものを変更したという訳ではない。したがってユーザは同値性ではなく同一性により識別されているのでエンティティとみなすことができる。

### エンティティの性質について
- エンティティの性質は以下の3つが挙げられる。値オブジェクトがもつ性質とは真逆の性質も存在するので、値オブジェクトについて理解しているとエンティティの理解も深めることができるだろう。
  - 可変である
  - 同じ属性であっても区別される
  - 同一性により区別される

#### 可変である
- 値オブジェクトは不変なオブジェクトであるのに対し、エンティティは可変なオブジェクトである。先の人間の年齢や身長が変化するのと同じように、エンティティも属性が変化することを許容している。
- ソフトウェアシステムにおいてユーザ名を変更するケースを考えてみよう。おそらく実装するコードは以下のようになるだろう。
```java
class User {
  private String userName;

  public User(String userName) {
      changeName(userName);
  }
  
  public void changeName(String name) {
      if (name == null) throw new IllegalArgumentException("ユーザ名が null です。");
      if (name.length() < 3) throw new IllegalArgumentException("ユーザ名は3文字以上でなければなりません。");
      
      this.userName = name;
  }
}
```
- 値オブジェクトと違い、ユーザ名の変更は User オブジェクトそのものを変更することによって行うのではなく、changeNameメソッドというふるまいを通じて User オブジェクトはそのままに userName フィールドの値のみ交換することによって行なっている。
- エンティティは属性が可変であることを許容するが、全ての属性を可変にする必要はない。値オブジェクトの項で説明したように属性を可変にするのはリスクを伴うので、必要なものだけ可変にするという方針を取るのが良いだろう。

#### 同じ属性であっても区別される
- 値オブジェクトは同じ属性であれば同じものとして区別されていたが、それに対しエンティティは同じ属性であったとしても別々のものとして区別される。人間を例にとって考えると、同姓同名の人間は言わずもがな同一人物だと言えないだろう。したがってエンティティは属性が同じかどうかという判断基準で識別されるのではなく、何か同一性を担保する識別子をもってして識別される。システムソフトウェアのユーザオブジェクトはよくユーザIDで識別される。

```java
class UserId {
    private String value;

    public UserId(String value) {
        if (value == null) throw new IllegalArgumentException("ユーザID が null です。");

        this.value = value;
    }
}

class User {
    private UserId userId;
    private String userName;

    public User(UserId userId, String userName) {
        if (userId == null) throw new IllegalArgumentException("ユーザID が null です。");
        if (userName == null) throw new IllegalArgumentException("ユーザ名 が null です。");

        this.userId = userId;
        this.userName = userName;
    }
}
```
- UserId がユニークならば、同じユーザ名のユーザが存在した場合でも、同一人物かどうかを判定することができる。

#### 同一性を持つ

- 一般的なシステムでは、ユーザ名を変更する前のユーザとした後のユーザは同一であると判断される方が望ましいだろう。したがってユーザの属性が異なっていたとしても、識別子が同じであるのならば同じユーザだと識別される仕組みが必要となる。以下のコードはUserIdという識別子を用いて同一性を判定している例である。
```java
class User {
    private UserId userId;
    private String userName;

    ...

    public UserId getUserId() {
        return userId;
    }

    @Override
    public boolean equals(Object obj) {
        final User other = (User) obj;

        return this.userId.equals(other.getUserId());
    }
}
```
- 値オブジェクトの時は全ての属性が比較の対象となっていたが、エンティティは識別子のみが比較の対象となる。これによってエンティティは属性が異なっていたとしても同一性の比較によって識別が可能となる。

### エンティティの判断基準としてのライフサイクルと連続性
- これまで値オブジェクトとエンティティについて説明してきた。ここで何を値オブジェクトにして何をエンティティにするかという判断基準はどうすればいいのかという疑問が湧いてくることだろう。これに関しては「そのオブジェクトがライフサイクルを持ち、連続性が存在するかどうか」という観点から考えてみるのがいいだろう。
- 例えばあるサービスのユーザを例に考えてみると、ユーザはサービス利用開始時に作成され、サービスを利用している間にユーザ情報の変更を行い、属性が変更される。そしてサービスの利用終了時にはそのユーザは削除されることだろう。したがってユーザというオブジェクトはライフサイクルをもち連続的に属性が変化するのでエンティティにするのが望ましいだろう。
- もしライフサイクルを表現することが無意味である場合は、ひとまず不変である値オブジェクトとして取り扱うのが良いだろう。

### 値オブジェクトとエンティティのどちらにもなりうるモデル
- あるドメインモデルを値オブジェクトにするか、エンティティにするかどうかは構築するシステムによっても変わってくる。例えばタイヤを例にとって説明すると、車にとってタイヤは交換可能なもので同一性も気にする必要もないため値オブジェクトとして定義するのが良いだろう。しかし、工場にとってはタイヤには製造番号を発行して個々を識別し、いつ作られたかなどの管理を行う必要があるのでエンティティとして定義するのが望ましいだろう。このようにシステムによってどちらの表現方法が最適かは考える必要があるだろう。

### まとめ
- 同値性ではなく、同一性によって識別されるオブジェクトをエンティティと呼ぶ。エンティティの特徴は以下の３つ。
  - 可変である
  - 同じ属性であって�����������������������区別される
  - 同一性によって識別される
- あるドメインモデルを値オブジェクトとして実装するか、エンティティとして実装するかは、「ライフサイクルをもち、連続性が存在するかどうか」で判断すると良い。
- 構築するシステムによっては値オブジェクトにするかエンティティにするかは検討すべきである。


## ドメインサービス

### ドメインサービスとは
- 今までで説明してきた値オブジェクトやエンティティは自身に振る舞いを持たせることができるオブジェクトだった。例えばユーザ名を表現する UserName オブジェクトにはユーザ名はある一定の文字数以上かどうかを判定する処理がドメインの知識として実装されていた。しかし、ドメインの知識ではあるが、値オブジェクトやエンティティに実装すると不自然となる振る舞いが存在する場合がある。その不自然な振る舞いを値オブジェクトやエンティティの代わりに実装するオブジェクトがドメインサービスとなる。システムソフトウェアにおけるサービスとはサービスを呼び出したクライアントの代わりに何か処理を行うというオブジェクトである。

#### 不自然なふるまいを確認する
- それでは値オブジェクトやエンティティに実装すると不自然になる振る舞いとは何かを例を用いて説明する。今あるシステムでユーザオブジェクトを実装したとする。そのシステムにおいてユーザは同一性を担保するために必ず他のユーザとは区別されなければならないとする。この場合、作成したユーザがユニークなのかを問い合わせる処理が必要となる。その処理を User オブジェクトで実装するとなると以下のようになる。
```java
class User {
  private UserId userId;
  private UserName userName;

  public User(UserId userId, UserName userName) {
      if (userId == null) throw new IllegalArgumentException("ユーザID が null です。");
      if (userName == null) throw new IllegalArgumentException("ユーザ名 が null です。");

      this.userId = userId;
      this.userName = userName;
  }

  public boolean isExists(User user) {
      // 重複確認を行うコード
  }
}
```

- しかし以下のように isExists メソッドを用いて重複確認を行うとすると妙なことが起きる。
```java
UserId userId = new UserId("id");
UserName userName = new UserName("fuga");
User user = new User(userId, userName);
boolean isUserDuplicated = user.isExists(user);
```

- この場合User オブジェクトは自分と同じユーザが存在するかどうかを自分自身に問い合わせている。このような実装は開発者を混乱させることであろう。このように値オブジェクトやエンティティにはそれらで定義すると不自然になってしまう振る舞いが存在する。

#### 不自然さを解決するオブジェクト

- それではこの不自然な振る舞いを解消するためにはどうすれば良いか？ここで登場するのがドメインサービスである。ドメインサービスを用いてこの重複確認の処理を実装すると以下のようになる。
```java
class UserService {
    
    public boolean isExists(User user) {
        // 重複確認を行うコード
    }
}
```

- ドメインサービスは値オブジェクトやエンティティと違い状態を持たないオブジェクトである。UserServiceを使用して重複確認を行うとすると以下のような実装となる。
```java
UserId userId = new UserId("id");
UserName userName = new UserName("fuga");
User user = new User(userId, userName);
UserService userService = new UserService();
boolean isUserDuplicated = userService.isExists(user);
```

- ドメインサービスを定義することで、値オブジェクトやエンティティが自身に重複を問い合わせることはなくなった。このコードなら開発者も混乱しなくて済むだろう。このように値オブジェクトやエンティティで定義すると不自然であった振る舞いは、代わりにドメインサービスで定義すると不自然さが解消される

### ドメインサービスの濫用が行き着く先

- ドメインサービスを使用する上で気をつけなければならないことは、ドメインサービスで定義する振る舞いは必ず「値オブジェクトやエンティティで実装すると不自然になるもの」に限定するということである。実を言うと、ドメインの全ての振る舞いはやろうと思えばドメインサービスで定義できてしまう。
- ユーザ名の変更処理を例にとって説明しよう。ユーザ名は3文字以上でなければならないという制約があった場合、ドメインサービスでその制約を実装すると以下のようになる。
```java
class UserService {
  
  public void changeName(User user, UserName userName) {
      if (userName.getValue() == null || userName.getValue().length() < 3) throw new IllegalArgumentException("ユーザ名は3文字以上でなければなりません。");
      
      user.setUserName(userName);
  }
}
```

- UserService を用いてユーザ名を変更する限りはユーザが設定される名前は必ず3文字以上となり、システムの要件は満たすことできる。しかし、このようなドメインサービスを定義した場合の User オブジェクトの実装を見てみよう。おそらく以下のようになるだろう。
```java
class User {
  private UserId userId;
  private UserName userName;

  public User(UserId userId, UserName userName) {
      this.userId = userId;
      this.userName = userName;
  }

  public UserId getUserId() {
      return userId;
  }

  public UserName getUserName() {
      return userName;
  }

  public void setUserName(UserName userName) {
      this.userName = userName;
  }
}
```

- このようにUserオブジェクト特有の制約が引き剥がされ、何も語りかけてこないオブジェクトになってしまう。開発者はこのクラスだけ見ただけでは、システムを利用しているユーザにどのような制約があるかを把握することは難しいだろう。
- 何も考えずにドメインの知識をサービスに実装することは、ドメインオブジェクトをただの get/set を行うだけのオブジェクトに変容させる結果を招いてしまう。このようにふるまいを持たずに開発者に何も語りかけてこないドメインオブジェクトの状態をドメインモデル貧血症と呼ぶ。これはデータとふるまいをまとめるというオブジェクト指向の戦略とは真逆を行くものである。
- ユーザ名を変更する振る舞いは本来であればユーザクラスに定義するものである。
```java
class User {
  private UserId userId;
  private UserName userName;

  public User(UserId userId, UserName userName) {
      if (userName.getValue() == null || userName.getValue().length() < 3) throw new IllegalArgumentException("ユーザ名は3文字以上でなければなりません。");

      this.userId = userId;
      this.userName = userName;
  }
  ...
}
```

#### 可能な限りドメインサービスを避ける
- 上述したように、ドメインモデル貧血症を引き起こすことを避けるために基本的にはオブジェクトの振る舞いは値オブジェクトやエンティティに実装する方が望ましい。値オブジェクトやエンティティに実装することにより、ドメインの知識をそれらに集約することができ、一元的に管理することができる。どうしても値オブジェクトやエンティティに実装するのが不自然だと感じる場合にのみドメインサービスに実装することが望ましいだろう。

### 物流システムに見るドメインサービスの例
- ここでは物流システムを例にとってドメインサービスの有効性を説明しよう。物流システムでは、荷物を拠点から直接配送するのではなく、配達先近くの物流拠点に輸送してから配送先まで荷物を配送する。この概念をコードに落とし込んでみよう。

#### 物流拠点の振る舞いとして定義する

- まずは物流拠点オブジェクト(PhysicalDistributionBase)でこの輸送という振る舞いを定義してみよう。２つの物流拠点間で行う輸送は、まず輸送元の拠点から貨物の出庫(Ship)を行い、輸送先の拠点に入庫(Receive)を行う必要があり、必ず出庫と入庫はセットで実行されるべきものである(さもなければ輸送を行わない貨物が出てきたり、架空の貨物を配送するといったことが行われるため)。この振る舞いを物流拠点オブジェクトで実装すると以下のようになる。
```java
class PhysicalDsitributionBase {

    // 出庫を行うメソッド
    public Baggage Ship(Baggage baggage) {
        ...
    }

    // 入庫を行うメソッド
    public void Receive(Baggage baggage) {
        ...
    }

    // 輸送を行うメソッド
    public void transPort(PhysicalDsitributionBase to, Baggage baggage) {
        Baggage shippedBaggage = Ship(baggage);
        to.Receive(shippedBaggage);

        // 輸送記録をつける etc..
    }
}
```
- 一応輸送の振る舞いは定義することができたが、よくよく考えると物流拠点というドメインオブジェクトが輸送を行うというのは不自然さが存在する。加えてシステムで全ての輸送記録などをつけなればならなくなった場合にはなおさら物流拠点がそれを行うのは違和感を持つことだろう。

#### 輸送ドメインサービスを定義する
- したがって輸送という振る舞いを物流拠点オブジェクトに実装するのは少し無理があるようである。そこで輸送ドメインサービス(TransportService)を定義してそこに実装するとなると、以下のような実装となる。
```java
class TransportService {

    // 輸送を行うメソッド
    public void transPort(PhysicalDsitributionBase from, PhysicalDsitributionBase to, Baggage baggage) {
        Baggage shippedBaggage = from.Ship(baggage);
        to.Receive(baggage);
        // 輸送記録をつける etc..
    }
}
```

- 物流拠点オブジェクトに実装していた場合よりも幾分かは自然な実装だと感じるだろう。そのオブジェクトの定義に納まらない操作を無理やり押し込むことになりそうな時は、ドメインサービスとして切り出すことがドメインの概念を自然に表現することに繋がる。

### まとめ
- クライアントの代わりにドメインの知識を実行するオブジェクトをドメインサービスと呼ぶ。
- 値オブジェクトやエンティティで実装すると不自然になるものはドメインサービスに実装すると自然な実装となる。
- ドメインモデル貧血症を引き起こすのを防ぐために、何でもかんでもドメインサービスでドメインロジックを実装することは避け、必要な場合にのみドメインサービスに実装することが望ましい。

## アプリケーションサービス

### アプリケーションサービスとは
- ドメイン駆動設計の実装パターンにおいて、サービスはドメインサービスとアプリケーションサービスの2つが存在するということを述べた。ドメインサービスはドメインオブジェクトであるのに対し、アプリケーションサービスはアプリケーションとしての機能を定義するオブジェクトである。例えば、あるシステムソフトウェアにおけるユーザの入会や退会処理といったユースケースをアプリケーションサービスで実装することとなる。その特性ゆえアプリケーションサービスは様々なドメインオブジェクトを駆使してそれらの振る舞いを実行することによりアプリケーションに必要な機能を組み立てる調整役のような役割を担う。

### アプリケーションサービスの実装例
- ユーザのCRUD操作を例にとってアプリケーションサービスの実装例を紹介しよう。

#### ドメインオブジェクトの定義
- まずアプリケーションサービスで使用するドメインオブジェクトを定義する。今回はユーザID, ユーザ名を表す値オブジェクトである UserId,UserNameクラス、そしてユーザを表すエンティティであるUserクラスを定義する。

```java
class UserId {
    private String value;

    public UserId(String value) {
        if (value == null) throw new IllegalArgumentException("ユーザID が null です。");

        this.value = value;
    }

    public String getValue() {
        return value;
    }
}

class UserName {
    private String value;

    public UserName(String value) {
        if (value == null || value.length() < 3) throw new IllegalArgumentException("ユーザ名 が 不正です。");

        this.value = value;
    }

    public String getValue() {
        return value;
    }
}

class User {
    private UserId userId;
    private UserName userName;

    public User(UserId userId, UserName userName) {
        this.userId = userId;
        this.userName = userName;
    }

    public UserId getUserId() {
        return userId;
    }

    public UserName getUserName() {
        return userName;
    }

    public void changeUserName(UserName userName) {
        this.userName = userName;
    }
}
```

#### リポジトリの定義、ドメインサービスの定義

- 次にアプリケーションサービスで使用するリポジトリとドメインサービスを定義する。
```java
// リポジトリ
interface UserRepository {

    public void insert(User user);

    public User find(String userId);

    public void update(User user);

    public void delete(User user);
}

// ドメインサービス
class UserDomainService {
    private UserRepository userRepository;

    public boolean isExists(User user) {
        User duplicatedUser = userRepository.find(user.getUserId().getValue());
        return duplicatedUser != null;
    }
}
```

#### ユーザ登録処理を作成する

- createUser メソッドはUserオブジェクトを作成したのち、重複判定を UserDomainService に依頼し、重複していない場合は UserRepository を使用してデータを登録している。
```java
// アプリケーションサービス
class UserApplicationService {

    private UserDomainService userDomainService;
    private UserRepository userRepository;

    public UserApplicationService(UserDomainService userService, UserRepository userRepository) {
        this.userDomainService = userService;
        this.userRepository = userRepository;
    }

    // ユーザ登録処理
    public void createUser(String userId, String userName) throws Exception {
        UserId newUserId = new UserId(userId);
        UserName newUserName = new UserName(userName);

        User newUser = new User(newUserId, newUserName);
        if (this.userDomainService.isExists(newUser)) {
            throw new Exception("すでにユーザが存在しています");
        }

        userRepository.insert(newUser);
    }
}
```

#### ユーザ情報取得処理を作成する

- ユーザ取得処理は以下のような実装が考えられるだろう。
```java

class UserApplicationService {

    ...

    // ユーザ情報取得
    public User readUser(String userId) throws Exception {
        User user = userRepository.find(userId);

        if (user == null) {
            throw new Exception("そのようなユーザは存在しません。");
        }

        return user;
    }

}
```
- しかし、ここで注目したいのはreadUserメソッドがUserオブジェクトを返しているという点である。このままだと、もしUserオブジェクトにドメインロジックが定義されていた場合に、このメソッドを呼び出すクライアントのクラスもドメインロジックの実行ができてしまい。ドメインロジックの実行が複数のクラスで行われてしまうことになる。極力ドメインロジックの実行はアプリケーションサービスに集約させたいので、クライアントにはドメインオブジェクトではなく、データ転送用オブジェクト(DTO: Data Transfer Object)にデータを移し変えて返却する。

```java

// データ転送用オブジェクト
class UserData {

    private String userId;
    private String userName;

    // User クラスを引数にすることで、フィールドか追加されてもコンストラクタのみ修正すれば良くなる
    public UserData(User user) {
        this.userId = user.getUserId().getValue();
        this.userName = user.getUserName().getValue();
    }

    public String getUserId() {
        return userId;
    }

    public String getUserName() {
        return userName;
    }
}

class UserApplicationService {

    ...

    public UserData readUser(String userId) throws Exception {
        User user = userRepository.find(userId);

        if (user == null) {
            throw new Exception("そのようなユーザは存在しません。");
        }

        return new UserData(user);
    }
}
```
- UserDataクラスはただ値を保持し、その値を参照されることだけを目的としているオブジェクトなので、クライアント側はドメインロジックの実行は不可能となる。これによりドメインロジックの実行はアプリケーションサービスに限定されることとなる。

#### ユーザ情報更新処理を作成する

- 更新は以下のような実装となる。
```java
class UserApplicationService {

    ...

    public void updateUser(UserData userData) throws Exception {

        User user = userRepository.find(userData.getUserId());
        if (user == null) {
            throw new Exception("そのようなユーザは存在しません。");
        }

        UserName userName = new UserName(userData.getUserName());
        user.changeUserName(userName);

        userRepository.update(user);
    }

}
```

#### ユーザ退会を作成する

- 退会処理は以下のようになる。
```java
class UserApplicationService {

    ...

    public void deleteUser(UserData userData) throws Exception {
        User user = userRepository.find(userData.getUserId());

        // 対象が見つからないため成功とする
        if (user == null) {
            return;
        }

        userRepository.delete(user);
    }

}
```

### アプリケーションサービスと凝集度

- プログラムには凝集度という概念が存在する。一般的に凝集度が高いクラスはシステムの処理における責任範囲が集中していて、そのクラスがどのような処理を担当しているのかというのが明確であるという特徴があげられる。したがって堅牢性や可読性などの観点からクラスの凝集度をできるだけ高くするのが望ましい。
- では凝集度とはどのように計算できるのだろうか？凝集度をはかる指標としてLCOM(Lack of Cohesion in Methods)という計算式が存在する。具体的な計算方法は省略するが、LCOMはクラスにおける全てのフィールドは全てのメソッドで使用されるべき、という思想に基づいている。したがってLCOMはフィールドとそれが利用されているメソッドがどれだけ存在するかで計算される。
- 凝集度が低いクラスを見てみよう。以下のようなクラスが凝集度が低いクラスである。

```java
public class LowCohesion {
    private String value1;
    private String value2;
    private String value3;
    private String value4;
    
    public String meghodA() {
        return value1 + value2;
    }

    public String meghodB() {
        return value3 + value4;
    }
}
```
- value1とvalue2はmethodAでのみ、value3とvalue4はmethodBでのみ使用されているので、このクラスは低凝集である。このクラスは2つのクラスに分離することで凝集度を高くすることができる。

```java
public class HighCohesionA {
    private String value1;
    private String value2;

    public String meghodA() {
        return value1 + value2;
    }
}

public class HighCohesionB {
    private String value3;
    private String value4;

    public String meghodB() {
        return value3 + value4;
    }
}
```
- 先ほどのCRUDアプリケーションも凝集度が高められないかどうかを見てみよう。UserDomainSerivce はユーザ登録処理のみでしか使用されていないので、アプリケーションサービスは複数のクラスに分離することができるだろう。

```java
class UserRegisterService {

    private UserDomainService userDomainService;
    private UserRepository userRepository;

    public UserApplicationService(UserDomainService userService, UserRepository userRepository) {
        this.userDomainService = userService;
        this.userRepository = userRepository;
    }

    // ユーザ登録処理
    public void createUser(String userId, String userName) throws Exception {
        UserId newUserId = new UserId(userId);
        UserName newUserName = new UserName(userName);

        User newUser = new User(newUserId, newUserName);
        if (this.userDomainService.isExists(newUser)) {
            throw new Exception("すでにユーザが存在しています");
        }

        userRepository.insert(newUser);
    }
}

class UserDeleteService {

    private UserRepository userRepository;

    public UserApplicationService(UserDomainService userService, UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public void deleteUser(UserData userData) throws Exception {
        User user = userRepository.find(userData.getUserId());

        // 対象が見つからないため成功とする
        if (user == null) {
            return;
        }

        userRepository.delete(user);
    }

}
```
- アプリケーションサービスを分離すると返ってクラス数が増えて管理が面倒になることも考えられるが、ユーザの操作処理を担当するアプリケーションサービスクラスは同じパッケージに含めるようにすることでこの課題は幾分か解消することができる。

### サービスについて
- ドメイン駆動設計にはドメインサービスとアプリケーションサービスの2種類のサービスが存在するが、両者の使い分けは目的に応じて行う。ドメインロジックの実装に関してはドメインサービス、アプリケーションにおける機能の実装に関してはアプリケーションサービスで行う。

### まとめ
- アプリケーションサービスはアプリケーションのユースケースをドメインオブジェクトの操作を行うことで実現するクラスである。
- アプリケーションサービスにロジックを実装するのはドメインの知識が複数のオブジェクトに実装されることになるので行わないようにする。

## 