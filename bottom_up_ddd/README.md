<!-- TOC -->

- [ボトムアップでわかる! ドメイン駆動設計入門](#ボトムアップでわかる-ドメイン駆動設計入門)
  - [Chapter 1 ドメイン駆動設計とは](#chapter-1-ドメイン駆動設計とは)
    - [ドメイン駆動設計とは](#ドメイン駆動設計とは)
    - [ドメイン駆動設計のメリット](#ドメイン駆動設計のメリット)
    - [なぜ今ドメイン駆動設計か](#なぜ今ドメイン駆動設計か)
  - [Chapter 2 システム固有の値を表現する「値オブジェクト」](#chapter-2-システム固有の値を表現する値オブジェクト)
    - [値オブジェクトとは](#値オブジェクトとは)
    - [値オブジェクトの特徴](#値オブジェクトの特徴)
    - [値オブジェクトを採用するメリット](#値オブジェクトを採用するメリット)
    - [値オブジェクトを使用するケース](#値オブジェクトを使用するケース)
  - [Chapter 3 ライフサイクルのあるオブジェクト「エンティティ」](#chapter-3-ライフサイクルのあるオブジェクトエンティティ)
    - [エンティティとは](#エンティティとは)
    - [エンティティの特徴](#エンティティの特徴)
  - [Chapter 4 不自然さを解決する「ドメインサービス」](#chapter-4-不自然さを解決するドメインサービス)
    - [ドメインサービスとは](#ドメインサービスとは)
    - [ドメインサービスを使用するケース](#ドメインサービスを使用するケース)
  - [Chapter 5 データにまつわる処理を分離する「リポジトリ」](#chapter-5-データにまつわる処理を分離するリポジトリ)
    - [リポジトリとは](#リポジトリとは)
    - [リポジトリの責務](#リポジトリの責務)
    - [リポジトリの実装方針](#リポジトリの実装方針)
    - [リポジトリを使用するメリット](#リポジトリを使用するメリット)
  - [Chapter 6 ユースケースを実現する「アプリケーションサービス」](#chapter-6-ユースケースを実現するアプリケーションサービス)
    - [アプリケーションサービスとは](#アプリケーションサービスとは)
    - [アプリケーションサービスを実装するにあたっての注意事項](#アプリケーションサービスを実装するにあたっての注意事項)
  - [Chapter 9 複雑な処理を行う「ファクトリ」](#chapter-9-複雑な処理を行うファクトリ)
    - [ファクトリとは](#ファクトリとは)
    - [ファクトリを使用するケース](#ファクトリを使用するケース)
  - [Chapter 11 アプリケーションを1から組み立てる](#chapter-11-アプリケーションを1から組み立てる)
  - [Chapter 12 ドメインのルールを守る「集約」](#chapter-12-ドメインのルールを守る集約)
    - [集約とは](#集約とは)
    - [集約の特徴](#集約の特徴)
    - [集約の区切り方](#集約の区切り方)
  - [Chapter 13 複雑な条件を表現する「仕様」](#chapter-13-複雑な条件を表現する仕様)
    - [仕様とは](#仕様とは)
    - [仕様の実装内容](#仕様の実装内容)
    - [仕様を使用するケース](#仕様を使用するケース)
  - [Chapter 14 アーキテクチャ](#chapter-14-アーキテクチャ)
    - [アーキテクチャの役目](#アーキテクチャの役目)
    - [代表的なアーキテクチャ](#代表的なアーキテクチャ)
      - [レイヤードアーキテクチャ](#レイヤードアーキテクチャ)
      - [ヘキサゴナルアーキテクチャ](#ヘキサゴナルアーキテクチャ)
      - [クリーンアーキテクチャ](#クリーンアーキテクチャ)

<!-- /TOC -->

# ボトムアップでわかる! ドメイン駆動設計入門

## Chapter 1 ドメイン駆動設計とは
- 以下の事項について説明できるようになることをゴールとする
  - ドメイン駆動設計とは
  - ドメイン駆動設計のメリット
  - なぜ今ドメイン駆動設計か

### ドメイン駆動設計とは
- ドメインの知識に焦点を当てた設計手法のことを指す。ここでいうドメインとは、プログラムを適用する対象領域のことを指す。例えば会計システムであれば帳票や金銭、配送システムでは倉庫や配送手段などがドメインに含まれる。ソフトウェアはユーザの課題を解消するために存在するので、その目的を果たすために役立つ知識や概念をドメインに含めて開発を行う必要がある。

### ドメイン駆動設計のメリット
- 汎用的なソフトウェアの設計のパターンを身に付けることができるので、設計段階で理想を現実に適合する場合に取るべき選択肢を増やしてくれる。
- ドメイン駆動設計によって開発されたソフトウェアは変更容易性が高くなる。

### なぜ今ドメイン駆動設計か
- ドメイン駆動設計が提唱されたのは2003年ごろと歴史があるものとなっているが、一昔前のソフトウェア開発はいち早く開発を完了しリリースすることが最も重要であると考えられていた。そのような背景から開発初期段階にモデリングに時間をかけるドメイン駆動設計は選択肢には入らなかった。しかし、速度を重視した開発は柔軟性や変更容易性が低いソフトウェアを生み出し、開発が進むにつれて場当たり的な修正を行う羽目になった。やがて開発者たちは速度よりも変更容易性の高いソフトウェアを開発することを望むようになり、結果としてドメイン駆動設計が注目されるようになった。

## Chapter 2 システム固有の値を表現する「値オブジェクト」
- 以下の事項について説明できるようになることをゴールとする
  - 値オブジェクトとは
  - 値オブジェクトの特徴
  - 値オブジェクトを採用するメリット
  - 値オブジェクトを使用するケース

### 値オブジェクトとは
システム固有の値を表したオブジェクトのことを指す。例えば、姓と名で構成される FullName を考えたときに、名前なのでプリミティブな String 型でも表現することができるが、FullNameクラスを定義することによって姓名それぞれを特定することが容易となって汎用性が高くなる。

### 値オブジェクトの特徴
- 値が不変
- 交換(代入)が可能である
  - 値オブジェクトの内部の値は不変だが、値オブジェクト自体は代入することができる。
- 等価性によって比較される
  - 同一性ではなく、等価性によって比較される。そのためには、比較用のメソッドを実装する必要がある。
- 属性が追加されても修正不要
  - 値オブジェクトに関する判定処理を値オブジェクト自身で実装することにより、変更箇所を最小限に留めることができる。

### 値オブジェクトを採用するメリット
- 表現力を増す
  - 単なるプリミティブ型で値を表現するより、ルールが表現されている値オブジェクトを使用した方が、どのような処理を行なっているのか、メソッドやコンストラクタの場合引数にどのようなものが渡されているのかが理解しやすくなる。
- 不正な値を存在させない
  - 「ユーザ名はN文字以上」といったルールをコンストラクタに組み込むことで、不正な値が入力されたことによる異常事態をいち早く気づくことができる。
- 誤った代入を防ぐ
  - 型を定義することにより、誤った代入が行われるのを防ぐ。例えば、本来ならユーザ名を代入するところをパスワードを代入したしまったケースなど。
- ロジックの散在を防ぐ
  - 値オブジェクトに関するロジックは値オブジェクトで定義した方が、ロジックがもし変更された場合でもクライアントのコードの変更は行わなくてもよくなるので、変更容易性が高いコードを作成することができる。

### 値オブジェクトを使用するケース
- まず、どの概念を値オブジェクトで表現するかだが、基準として何かの業務ルールが存在する場合は値オブジェクトの作成を検討する。例えば、パスワードを設定する際に文字数の制限や使用できる文字の種類が決まっている場合はパスワードを単なるプリミティブ型で表現するのではなく、値オブジェクトとして表現した方が良い。

## Chapter 3 ライフサイクルのあるオブジェクト「エンティティ」
- 以下の事項について説明できるようになることをゴールとする
  - エンティティとは
  - エンティティの特徴

### エンティティとは
- エンティティとは、同一性で区別されるオブジェクトのことを指す。例えば、システムのユーザの多くは自身でユーザの情報を変更することができるが、情報を変更したからといってユーザ自身が変更後別のユーザになるということはない。こういったオブジェクトのことをエンティティと呼ぶ。

### エンティティの特徴
- 可変である
  - 値オブジェクトと異なり、エンティティは可変の要素をもつ(ユーザの身長など)場合が存在する
- 同じ属性であっても区別される
  - 姓名は属性であり、同姓同名の人間が同じ人間かと言われると違うように、エンティティも属性が同じだからとはいえ同じものだと区別はされない。
- 同一性により区別される
  - ユーザ情報を変更したからといって変更前と変更後は違うユーザとなるということはない。これはユーザは同一性の検証によって同じユーザであると判定されているためである。したがってエンティティの同一性を検証する方法が必要だが、大抵はIDなどを元に同一性を検証することとなる。

## Chapter 4 不自然さを解決する「ドメインサービス」
- 以下の事項について説明できるようになることをゴールとする
  - ドメインサービスとは
  - ドメインサービスを使用するケース

### ドメインサービスとは
- ドメインサービスとは、値オブジェクトやエンティティで実装するには直感的でなくきまりが悪いロジックを実装するクラスのことを指す。例えば、そのユーザ名が既に存在しているかどうかの検証メソッドを実装する場合、エンティティ自身にこのロジックを実装させるのはいささか違和感が伴う。ここでドメインサービスでこの検証処理を実装すれば不自然さを解消することができる。

### ドメインサービスを使用するケース
- まず、なんでもかんでもドメインサービスにロジックを実装すべきではない。値オブジェクトやエンティティの表現力が低下するからである。これをドメインモデル貧血症と呼ぶ。可能な限りドメインサービスでロジックを実装することは避け、どうしてもロジックが値オブジェクトやエンティティの責務ではない場合にのみ実装する。

## Chapter 5 データにまつわる処理を分離する「リポジトリ」
- 以下の事項について説明できるようになることをゴールとする
  - リポジトリとは
  - リポジトリの責務
  - リポジトリの実装方針
  - リポジトリを使用するメリット

### リポジトリとは
- リポジトリは、データストアなどを使用してデータの永続化や再構築を行うためのオブジェクトのことをさす。

### リポジトリの責務
- リポジトリはデータの永続化や再構築を行うオブジェクトなので、ドメインロジックはリポジトリでは実装すべきではない。ドメインオブジェクトはあくまでドメインサービスや値オブジェクト、エンティティで実装する。

### リポジトリの実装方針
- リポジトリは基本的にはインターフェースを切って実装を行う

### リポジトリを使用するメリット
- データストアへの接続やSQLの発行をリポジトリで実装することにより、ドメインサービスではそれらの処理を気にせずにロジックを組み立てることができる
- テストを実行する場合はテスト用のリポジトリを定義することによって実際にデータストアを使用することなくテストを実行することができる。

## Chapter 6 ユースケースを実現する「アプリケーションサービス」
- 以下の事項について説明できるようになることをゴールとする
  - アプリケーションサービスとは
  - アプリケーションサービスを実装するにあたっての注意事項
  - アプリケーションサービスを使用するケース

### アプリケーションサービスとは
- ドメインサービスとは異なり、ドメインオブジェクトを組み合わせてシステムを利用するユーザが取りうるアクション(サービス利用開始、基本情報変更、退会 etc...)を体現するのがアプリケーションサービスである。

### アプリケーションサービスを実装するにあたっての注意事項
- アプリケーションサービスでクライアントにドメインオブジェクトをそのまま渡すのは避けるべきである。なぜならドメインオブジェクトを渡すとクライアント側でもドメインロジックを実行することができてしまい、ドメインロジックを実行するという責務をあらゆる層が持つことになるからである。これを避けるためにアプリケーションサービスはドメインオブジェクトではなく Data Transfer Object (DTO)を渡すことがあげられる。
- アプリケーションサービスではドメインロジックを実装するべきではない。あくまでアプリケーションサービスはドメインオブジェクトやそのメソッドを呼び出すにとどめておく。例えば、ユーザの検索処理はアプリケーションサービスで実装すると、検索処理自体のロジックを変更する場合にはそれぞれ使用している箇所を全て修正しなければならないが、ドメインサービスで実装すればアプリケーションサービスはその修正したメソッドを呼び出すだけで機能を修正できる。
- アプリケーションサービスはなるべく凝集度を高くすることが重要である。凝集度をはかる指標としてLCOMというものが存在し、これはクラスのフィールドがどのメソッドで使用されているかを測る物である。
- アプリケーションサービスをインターフェースとして定義すると、クライアントはそのインターフェースを使用することにより、実装完了を待たずしてクライアント側の処理を実装できる。

## Chapter 9 複雑な処理を行う「ファクトリ」
- 以下の事項について説明できるようになることをゴールとする
  - ファクトリとは
  - ファクトリを使用するケース

### ファクトリとは
- 複雑なオブジェクトの生成処理を定義したオブジェクトのことを向上となぞらえてファクトリと呼ぶ。ファクトリを定義することにより、クライアントはオブジェクトを生成するに至るまでの複雑な処理の過程を知ることなく目的のオブジェクトを生成することができる

### ファクトリを使用するケース
- インスタンスを生成するという観点から、ファクトリはコンストラクタと責務が同じであると捉えることができるが、コンストラクタとの使い分けに関しては、コンストラクタはインスタンスの生成が比較的単純な場合に使用する。コンストラクタの中で別のオブジェクトを生成するようなことがあった場合、そのオブジェクトが変更されたらコンストラクタも変更する恐れがあるのでこういった場合はファクトリで実装した方が良い。

## Chapter 11 アプリケーションを1から組み立てる
- アプリケーションを作成するフローについて説明できるようにする
- デモンストレーションを通して気づいた点をまとめる

## Chapter 12 ドメインのルールを守る「集約」
- 以下の事項について説明できるようになることをゴールとする
  - 集約とは
  - 集約の特徴
  - 集約の区切り方
  - 集約を使用するケース

### 集約とは
- オブジェクトの不変条件を適用する単位。集約を定義することにより、オブジェクトに秩序をもたらす。例えば、以下のように Circle の名前を変更する擬似コードを考える

```kt
val circle = Circle()
circle.name = "CircleA"  // 1.
circle.changeName("CircleA")  // 2.
```
1. より2. が優れている点としては、メソッドで切り出したことにより不変条件(名前が〇〇文字以上になっているかどうか、null が指定されていないか)の判定を行うことができるところにある。ここで変更を命令を問い合わせる対象である circle のことを集約ルートと呼ぶ。また、Circle には name の他に、member, equipment などのプロパティも存在することが考えられる。こういった集約内に存在する要素のことを境界と呼ぶ。

### 集約の特徴
- 不変条件を適用する一つの単位である
- オブジェクトに変更を加える場合は集約ルートに対して問い合わせるしかないので、むやみやたらに外部から状態を変更されることを防ぐことができる

### 集約の区切り方
- ある集約から異なる集約の要素を変更するような実装は避ける。
- 集約はできるだけ小さく保つ。複数のトランザクションを張る場合はそれ全体を集約として扱わない方が良い。

## Chapter 13 複雑な条件を表現する「仕様」
- 以下の事項について説明できるようになることをゴールとする
  - 仕様とは
  - 仕様の実装内容
  - 仕様を使用するケース

### 仕様とは
- アプリケーションを作成するにあたりオブジェクトに対する判定ロジックを実装するのはよくあることである。単純なロジックはそのオブジェクトに実装すれば良いが、複雑な判定ロジックを実装する場合には、仕様に基づいて判定を行うオブジェクトを別途定義し判定を行わせるのも一つの手である。
- 例えば User のタイプに応じて Circle の人数の上限を変更するケースを考える。ここで Circle オブジェクトが集約の観点から User そのものではなく UserId を内部で保持している場合、上限を判定するロジックを Circle オブジェクトで実装する場合、 Repository クラスをメソッドに渡して上げる必要がある。しかし、ドメインオブジェクトである Circle に本来DDDの概念ではない Repository を追加することは望ましくない。したがって Circle オブジェクトと Repository を受け取って上限を判定する仕様オブジェクトを作成するのが望ましい。また、Repositoryを渡さずともアプリケーションサービスで Repository からUserを取得し、そのリストを渡してあげることでも実現可能である。この場合仕様もドメインオブジェクトのみで構成されるので一貫性を保つことができる

### 仕様の実装内容
- 仕様の適用をアプリケーションサービスで行うか、Repository に仕様インターフェースを渡して判定を行うかの２択が存在する。

### 仕様を使用するケース
- あるリストに対して何かフィルタリングを行うような場合に有効な考え方の一つである。

## Chapter 14 アーキテクチャ
- 以下の事項について説明できるようになることをゴールとする
  - アーキテクチャの役目
  - 代表的なアーキテクチャ
    - レイヤードアーキテクチャ
    - ヘキサゴナルアーキテクチャ
    - クリーンアーキテクチャ

### アーキテクチャの役目
- ECサイトを例にあげて説明すると、ECサイトで注文詳細、履歴、購入確定画面で合計金額を表示する場合、各画面で合計金額を計算するロジックを実装していると、計算ロジックに変更が発生した場合には全ての画面のロジックの変更を余儀なくされ、修正コストが高くなる。したがってUIには極力ロジックを持たせない方が良い。ロジックを持ったUIを「利口なUI」と呼ぶ。こういったケースの解決策としては、サーバ側で計算ロジックを実装し、UIはその結果を受け取って表示するだけに止めることである。
- 上記のUIの例でもあるように、ロジックを適切な箇所に実装することはソフトウェアを開発する際には重要である。そのロジックをどこに実装するかの指針を示しているのがアーキテクチャと呼ばれるものである。

### 代表的なアーキテクチャ
#### レイヤードアーキテクチャ
- プレゼンテーション層、アプリケーション層、ドメイン層、インフラストラクチャ層で構成されるアーキテクチャ。プレゼンテーション -> アプリケーション -> ドメイン -> インフラストラクチャ という依存の矢印をもち、下位層は上位層に依存してはならない。

#### ヘキサゴナルアーキテクチャ
- 入力と出力の実装に依存せずにドメインロジックを守るように設計されたアーキテクチャ。入力と出力にはそれぞれアダプタとポートが存在し、それぞれアダプタがクライアント、ポートが実行するメソッドのことを指す。アダプタがポートに必要なの引数のインスタンスを生成し、ポートが実際にそれを用いて処理を実行する。ポートはインターフェースで定義されているため、入力と出力の汎化を実現している。

#### クリーンアーキテクチャ
- クリーンアーキテクチャはヘキサゴナルアーキテクチャと似ているが、ヘキサゴナルと異なる点として具体的な実装方針が述べられている点である。Controller -> Use Case Input Port(I) <|- Use Case Interactor -> Use Case Output Port(I) <|- Presenter といった依存、汎化関係が存在し、処理のフローは Controller -> Use Case Interactor -> Presenter の順となる。Controller は User Case は Use Case Input Port 越しに Interactor を呼び出すので、スタブを用意することでテストを容易に実行することができる。また Use Case Interactor も Use Case Output Port 越しに Presenter を呼び出すので、同様にテスト容易性を高めることができる。このようにドメインロジックを隔離できるのがクリーンアーキテクチャの利点である。