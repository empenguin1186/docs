<!-- TOC -->

- [HTTP/1.0 のシンタックス：基本となる4つの要素](#http10-のシンタックス基本となる4つの要素)
    - [MIME タイプ](#mime-タイプ)
    - [ステータスコード](#ステータスコード)
    - [リダイレクト](#リダイレクト)
    - [URLの構成](#urlの構成)
- [HTTP/1.0 のセマンティクス：ブラウザの基本機能の裏側](#http10-のセマンティクスブラウザの基本機能の裏側)
    - [シンプルなフォームの送信](#シンプルなフォームの送信)
    - [フォームを使ったファイルの送信](#フォームを使ったファイルの送信)
    - [フォームを利用したリダイレクト](#フォームを利用したリダイレクト)
    - [コンテントネゴシエーション](#コンテントネゴシエーション)
    - [Cookie について](#cookie-について)
        - [クッキーの問題点](#クッキーの問題点)
        - [クッキーの制約](#クッキーの制約)

<!-- /TOC -->

# HTTP/1.0 のシンタックス：基本となる4つの要素

## MIME タイプ
MIMEタイプはファイルの種類を区別するための文字列で、電子メールのために作られました。

## ステータスコード

ステータスコードについては以下の表を参照してください。

| ステータスコード | 意味 |
|:--------------:|:----|
| 100 番台 | 処理中の情報の伝達 |
| 200 番台 | 成功時のレスポンス　|
| 300 番台 | サーバからクライアントへの命令。エラーではなく、正常処理の範疇。リダイレクトやキャッシュの使用を指示する。 |
| 400 番台 | クライアントのリクエストに問題があった場合に返される |
| 500 番台 | サーバ内部でエラーが発生した場合にクライアントに渡される |

## リダイレクト

300番台のステータスコードが返されたときは、クライアントはレスポンスのLocation ヘッダからリダイレクト先を取得し、再度リクエストを行う。
リダイレクトのパターンは主に 3パターンに分類される。

| ステータスコード | 意味 |
|:--------------:|:----|
| 301/308 | リクエストされたページが別の場所に移動した時に返される。検索エンジンはこのレスポンスを受け取ると既存のページの評価を新しいページに受け継ぐ。 |
| 302/307 | 一時的な移動。モバイル専用ページに遷移したり、メンテナンスページに移動するときなどに返される。　|
| 308 | リクエストされたページに返すべきコンテンツが存在しない、あるいは本来返すべきページが別にある場合、そちらにジャンプさせるために使用する。ログインページにアクセスしてログインした場合、元のページに戻る時に使用する。 |

## URLの構成

https://www.oreilly.co.jp/index.shtml

| 要素 | 名前 |
|:--------------:|:----|
| https | スキーマ |
| www.oreilly.co.jp | ホスト名　|
| index.shtml | パス |

# HTTP/1.0 のセマンティクス：ブラウザの基本機能の裏側

## シンプルなフォームの送信

`curl`コマンドで`-d`オプションをつけると、ブラウザで入力フォームに入力して送信した時と同じようにヘッダに`Content-Type: application/x-www-form-urlencoded`が付与されます。

## フォームを使ったファイルの送信

HTMLのフォームではオプションでマルチパートフォーム形式というエンコードタイプを選択することができます。これを指定すると複数のファイルを送信することができます。マルチパートフォーム形式を選択すると、以下のようなヘッダが付与されます。

```
Content-Type: multipart/form-data; boundary=<hoge>
```
ここで`boundary=<hoge>`という記述はファイルを区切る文字を表しています。この文字で区切られたデータが複数のデータの一つと認識されます。

## フォームを利用したリダイレクト

リダイレクトには以下の2点の課題が存在します。  
- URLは200文字に抑えるべきという目安が存在するので、GETのクエリで送信できるデータには限界がある  
- データがURLに入ってしまうため、送信したい内容がアクセスログに残ってしまう懸念がある  

そういった課題を解決するのに使われるのが、`<hidden>` タグを使ったリダイレクトです。

## コンテントネゴシエーション
クライアントとサーバは別々で開発されているケースが存在するので、クライアントサーバ間のリクエストでは両方で期待している形式や設定が異なるケースが存在します。したがってクライアントとサーバ間でリクエストの形式や設定を統一する方法が必要となってきます。コンテントネゴシエーションとは1リクエストでクライアントとサーバでお互いのベストな設定を共有する仕組みです。ネゴシエーションする対象と、それに使用するヘッダは以下の通りです。

|リクエストヘッダ|レスポンス|ネゴシエーション対象|
|:------------:|:-------|:---------------|
|Accept|Content-Type ヘッダ|MIMEタイプ|
|Accept-Language|Content-Language ヘッダ /html タグ| 表示言語 |
|Accept-Charset|Content-Type ヘッダ | 文字のキャラクターセット | 
|Accept-Encoding|COntent-Encoding ヘッダ | ボディの圧縮 | 

## Cookie について
クッキーはウェブサイトの情報をブラウザ側に保存する仕組みです。例としてサーバ側から以下のようなレスポンスヘッダが返ってきたとします。

```
Set-Cookie: LAST_ACCESS_DATE=Jul/31/2016
Set-Cookie: LAST_ACCESS_TIME=12:04
```

クライアント側は再度リクエストを行う時にこのクッキーを含めてリクエストを行うと、サーバ側は最後にクライアントがアクセスして来た日時を知ることができます。

```
Cookie: LAST_ACCESS_DATE=Jul/31/2016
Cookie: LAST_ACCESS_TIME=12:04
```

これによりステートレスなHTTPリクエストであたかもサーバがステートフルに見えるようになります。  

### クッキーの問題点
クッキーには以下の注意点があります。

- 永続性の問題:　クッキーはどんな状況でも確実に保存される訳ではない。  
- 容量の問題: クッキーには容量の制限が存在し、4kb までしか保存できない。  
- セキュリティの問題: クッキーの送受信は平文で行われるため、パスワードなどをクッキーで保存した場合、盗聴される可能性がある。それを避ける署名や暗号化が必要。  


### クッキーの制約


# 1章
- 電子メールの形式
  - ヘッダパートと本文パートに分かれており、その間には空行が存在する。

# 2章
- ファイルの送信
  - Content-Type: multipart/form-data でのファイル送信を行う場合は、ヘッダにファイルの名前やファイルの種類といったメタ情報を付与することができる。
- リダイレクト
  - `<input type="hidden">` のフォームの送信先がリダイレクト先となる。
- コンテントネゴシエーション
  - 
- クッキー
  - HTTPリクエストをステートフルにするためにサーバ側がクライアント側に保存させる情報
  - secure 属性を付与しない限りクッキーは平文で送信されるので、パスワードを保存させるのは危険である。また、最大容量は4KB。必ず保存されるわけではないので、削除されたら困る情報はクッキーに含めない方が良い。
- 認証とセッション
  - 
- プロキシ
- キャッシュ
- リファラー
- 検索エンジン向けのコンテンツのアクセス制御

# 3章

# 4章 HTTP/1.1 のシンタックス
- 通信の高速化
  - Keep-Alive
  - パイプライニング
- TLS(トランスポートレイヤセキュリティ)
  - 
- プロトコルのアップグレード

# 5章 HTTP/1.1 のセマンティクス
- ファイルをダウンロードした後でローカルに保存
- ダウンロードの中断、再開
- XMLHttpRequest
- Geo-Location
- X-Powered-By ヘッダ
- リモートプロシージャコール
- WebDAV
  - 分散ファイルシステムを実現する技術
- ウェブサイト間で共通の認証・認可のプラットフォーム

# 6章

# 7章 HTTP/2 のセマンティクス
- HTTP2について
  - 処理が高速
    - TCP接続の内部にストリームという仮装のTCPソケットを作って通信を行うことができ、並列リクエストが可能となる
    - テキストベースの通信であったHTTP1.1とは異なり、HTTP2ではバイナリベースでの通信に変わったため高速な処理が可能となった(HTTP1.1はテキストのパース処理などの逐次処理が発生するためその分パフォーマンスはおとる)。
  - ヘッダとボディしか存在しない
    - パスやメソッドなどもヘッダに設定される
  - サーバプッシュ
    - サーバ側が優先度の高いコンテンツをクライアントが要求する前に送信することができる機能。クライアントは実際にそのコンテンツをリクエストするまでは、そのコンテンツを受信していることを検知できない。コンテンツはキャッシュとして格納される
  - Fetch API
    - XMLHttpRequestとは異なる点
      - キャッシュの制御が可能
      - リダイレクトの制御が可能
      - Service Worker に対応している
        - [サービスワーカー API - Web API | MDN](https://developer.mozilla.org/ja/docs/Web/API/Service_Worker_API)
        - [Service Worker の紹介  |  Web Fundamentals  |  Google Developers](https://developers.google.com/web/fundamentals/primers/service-workers/)
- WebSocket
  - WebSocketとはクライアントとサーバ間で双方向通信を行う際に使用できるプロトコルである。
  - WebSocketはサーバ上にデータをオンメモリで管理するケースが多い。これは、オンラインゲームなどリアルタイム性が高いコンテンツで使用されることが多いためである。オンメモリで管理するため、接続が切断された場合は同じサーバに対して再び接続しなければならないためHTTPベースのロードバランサは使用できない。直接クライアントが再接続先のサーバを指定してリクエストするか、TCPベースのロードバランサを使用するかの対策を講じる必要がある。
  - WebSocketを用いた通信はHTTPの機能であるプロトコルのアップグレードを使用することで行う。Upgradeヘッダにwebsocketを指定してリクエストを実行する。

- WebRTC
  - WebRTCはクライアントとサーバ間だけでなく、クライアントとクライアント間のP2Pの通信を実現するプロトコルである。主にSkypeなどのオンラインでのビデオ会話ツールなどで使用されている。

- HTTPウェブプッシュ
  - HTTPウェブプッシュはスマートフォンのアプリの通知機能のようなものをWebアプリケーションに提供する機能である。
  - 処理の流れは以下。登場人物としてエンドユーザが使用するブラウザ、Push通知を送るプッシュサービス、ユーザが利用するWebアプリケーションが存在する。
    - ブラウザ起動時にプッシュ通知機能を利用するかをユーザから許可を得る。許可を得た際には Service Worker で登録したPushイベントで通知が受け取れるようになる。Serivice Worker はフロントエンドとWebサーバの中間に存在するプロキシのようなものである。
    - アプリケーションサーバがプッシュ通知をクライアントに送るためには、プッシュサービスのAPIを利用する。Webアプリケーションの通知を受信するかどうかをブラウザがクライアントに許可を取り、許可を得た場合にプッシュサービスに登録を行う。この際に通知を送信するブラウザを特定する鍵を作成する
    - その後ブラウザはプッシュ通知に必要な鍵をアプリケーションに送信する。アプリケーションはこの鍵情報を含めてプッシュサービスにリクエストを行うことで特定のブラウザに通知を送ることができる。
# 8章
- レスポンシブデザイン
- セマンティックウェブ
- オープングラフプロトコル
- AMP(Accelerated Mobile Pages)
- HTTP ライブストリーミングによる動画のストリーミング再生
- MPEG-DASHによる動画ストリーミング再生

# 9章
- 

# 10章
- 

# 11章
